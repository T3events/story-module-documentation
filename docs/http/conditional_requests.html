<h1>Conditional requests</h1> <p class="summary">HTTP has a concept of <em>conditional requests</em>, where the result, and even the success, of a request can be changed by comparing the affected resources with the value of a <em>validator</em>. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</p> <h2 id="Principles">Principles</h2> <p>HTTP conditional requests are requests that are executed differently depending on the value of specific headers. These headers define a precondition and the result of the request will be different if the precondition is matched or not.</p> <p>The different behaviors are defined by the method of the request used and by the set of headers used for a precondition:</p> <ul> <li>for <a title="safe: An HTTP method is safe if it doesn't alter the state of the server. In other words, a method is safe if it leads to a read-only operation. Several common HTTP methods are safe: GET, HEAD, or OPTIONS. All safe methods are also idempotent as well as some, but not all, unsafe methods like PUT, or DELETE." href="https://developer.mozilla.org/en-US/docs/Glossary/safe" class="glossaryLink">safe</a> methods, like <a title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data." href="methods/get"><code>GET</code></a>, which usually tries to fetch a document, the conditional request can be used to send back the document if relevant only and therefore spares bandwidth.</li> <li>for <a title="unsafe: An HTTP method is safe if it doesn't alter the state of the server. In other words, a method is safe if it leads to a read-only operation. Several common HTTP methods are safe: GET, HEAD, or OPTIONS. All safe methods are also idempotent as well as some, but not all, unsafe methods like PUT, or DELETE." href="https://developer.mozilla.org/en-US/docs/Glossary/safe" class="glossaryLink">unsafe</a> methods, like <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a>, which usually uploads a document, the conditional request can be used to upload the document only if the original it is based on is the same that is stored on the server.</li> </ul> <h2 id="Validators">Validators</h2> <p>All conditional headers try to check if the resource stored on the server matches a specific version. To achieve this, the conditional requests need to indicate the version of the resource. As comparing the whole resource byte to byte is impracticable (and not even always what is wanted!), the request transmits a value describing the version: such values are called <em>validators</em> and are of two kinds:</p> <ul> <li>the date of last modification of the document, the <em>last-modified</em> date.</li> <li>an opaque string, uniquely identifying each version, called the <em>entity tag</em> or the <em>etag</em>.</li> </ul> <p>Comparing versions of the same resource is a bit tricky: depending of the context, there are two kind of equality checks. <em>Strong validation</em> is used when byte to byte identity is expected, for example when resuming a download. <em>Weak validation</em> is used when the user-agent only needs to determine if the two resources have the same content, even if they are minor difference (like different ads, or a footer with a different date).</p> <p>The kind of validation is independent of the validator used; both <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> and <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> allow both types of validation though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</p> <h3 id="Strong_validation">Strong validation</h3> <p id="sect1">Strong validation consists in guaranteeing that the resource is byte to byte identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantes no data loss at any time, sometimes at the expense of performance.</p> <p>It is quite difficult to have a unique identifier for strong validation with <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a>. Often this is done using an <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> with the MD5 hash of the resource (or a derivative).</p> <h3 id="Weak_validation">Weak validation</h3> <p>Weak validation differs from strong validation as it considers two versions of the document as identical if the content is equivalent. For example, a page that would differ from another only by a different date in its footer, or by different advertisement, would be considered as identical to the other with weak validation, but will be considered as different with strong validation. Building a system of etags that creates weak validation may be complex as it involves knowing the importance of the different elements of a page, but is very useful to optimize caching performance.</p> <h2 id="Conditional_headers">Conditional headers</h2> <p>Several HTTP headers, called conditional headers, lead to conditional requests. These are:</p> <dl> <dt><a title="The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case." href="headers/if-match"><code>If-Match</code></a></dt> <dd>Succeeds if the <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with <code>'W/'</code>, it performs a strong validation.</dd> <dt><a title="The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if doesn't have a ETag matching the given one. For other methods, the request will be processed only if the eventually existing resource's ETag doesn't match any of the values listed." href="headers/if-none-match"><code>If-None-Match</code></a></dt> <dd>Succeeds if the <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with <code>'W/'</code>, it performs a strong validation.</dd> <dt><a title="The If-Modified-Since request HTTP header makes the request conditional: the server will send back the requested resource, with a 200 status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a 304 without any body; the Last-Modified header will contain the date of last modification. Unlike If-Unmodified-Since, If-Modified-Since can only be used with a GET or HEAD." href="headers/if-modified-since"><code>If-Modified-Since</code></a></dt> <dd>Succeeds if the <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> date of the distant resource is more recent than the one given in this header.</dd> <dt><a title="The If-Unmodified-Since request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a POST or another non-safe method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a 412 (Precondition Failed) error." href="headers/if-unmodified-since"><code>If-Unmodified-Since</code></a></dt> <dd>Succeeds if the <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> date of the distant resource is older or the same than the one given in this header.</dd> <dt><a title="The If-Range request HTTP header makes the range request conditional: if the condition is fulfilled, the range request will be and the server send back a 206 Partial Content answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a 200 OK status." href="headers/if-range"><code>If-Range</code></a></dt> <dd>Similar to <a title="The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case." href="headers/if-match"><code>If-Match</code></a>, or <a title="The If-Unmodified-Since request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a POST or another non-safe method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a 412 (Precondition Failed) error." href="headers/if-unmodified-since"><code>If-Unmodified-Since</code></a>, but can have only one single etag, or one date. If it fails, a the range request fails and, instead of a <a title="The HTTP 206 Partial Content success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the Range header of the request." href="status/206"><code>206</code></a> <code>Partial Content</code> response, a <a title="The HTTP 200 OK success status response code indicates that the request has succeeded. A 200 response is cacheable by default." href="status/200"><code>200</code></a> <code>OK</code> is sent with the complete resource.</dd> </dl> <h2 id="Use_cases">Use cases</h2> <h3 id="Cache_update">Cache update</h3> <p>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resources is sent back with a status of <a title="The HTTP 200 OK success status response code indicates that the request has succeeded. A 200 response is cacheable by default." href="status/200"><code>200</code></a> <code>OK</code>.</p> <p><img src="https://mdn.mozillademos.org/files/13729/Cache1.png" style="height: 265px; width: 741px;" alt="The request issued when the cache is empty triggers the resource to be downloaded, with both validator value sent as headers. The cache is then filled."></p> <p>Together with the resource, the validators are sent in the headers. In this example, both <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> and <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> are sent, but it could have been only one of them as well. These validators are cached with the resource (like all headers) and will be used to craft conditional requests once the cache becomes stale.</p> <p>As long as the cache is not stale, no requests are issued at all. But once, it has become stale, this is mostly controlled by the <a title="The Cache-Control general-header field is used to specify directives for caching mechanisms in both, requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response." href="headers/cache-control"><code>Cache-Control</code></a> header, the client doesn't use the cached value directly but issues a <em>conditional request</em>, with the value of the validator used as parameter of the <a title="The If-Modified-Since request HTTP header makes the request conditional: the server will send back the requested resource, with a 200 status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a 304 without any body; the Last-Modified header will contain the date of last modification. Unlike If-Unmodified-Since, If-Modified-Since can only be used with a GET or HEAD." href="headers/if-modified-since"><code>If-Modified-Since</code></a> and <a title="The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case." href="headers/if-match"><code>If-Match</code></a> headers.</p> <p>If the resource has not been changed, the server sends back a <a title="The HTTP 304 Not Modified client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is safe, like a GET or a HEAD request, or when the request is conditional and uses a If-None-Match or a If-Modified-Since header." href="status/304"><code>304</code></a> <code>Not Modified</code> response, which makes the cache fresh again and the client use the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</p> <p><img src="https://mdn.mozillademos.org/files/13731/HTTPCache2.png" style="height: 265px; width: 741px;" alt="With a stale cache, the conditional request is sent. The server can determine if the resource changed, and, as in this case, decide not to send it again as it is the same."></p> <p>If the resource has changed, the server just sends back a <a title="The HTTP 200 OK success status response code indicates that the request has succeeded. A 200 response is cacheable by default." href="status/200"><code>200</code></a><code> OK</code> response, with the new version of the resource, like if the request wasn't conditional and the client use this new resource (and caches it).</p> <p><img src="https://mdn.mozillademos.org/files/13733/HTTPCache3.png" alt="In the case where the resource was changed, it is sent back as if the request wasn't conditional."></p> <p>Besides setting the validators on the server side, this mechanism is transparent: all browsers manage a cache and send such conditional requests without any special work to be done by Web developers.</p> <h3 id="Integrity_of_a_partial_download">Integrity of a partial download</h3> <p>Partial downloading of files is a functionality of HTTP that allows to resume previous operations, saving bandwidth and time by keeping the already obtained information.</p> <p><img src="https://mdn.mozillademos.org/files/13735/HTTPResume1.png" style="height: 397px; width: 764px;" alt="A download has been stopped and only partial content has been retrieved."></p> <p>A server supporting partial downloads advertised it by sending the <a title="The Accept-Ranges response HTTP header is a marker used by the server to advertise its support of partial request. The value of this field indicates the unit that can be used to define the range." href="headers/accept-ranges"><code>Accept-Ranges</code></a> header. When this happens, the client can resume a download by sending a <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Ranges"><code>Ranges</code></a> header with the missing ranges.</p> <p><img src="https://mdn.mozillademos.org/files/13737/HTTPResume2.png" alt="The client resumes the requests by indicating the range he needs and preconditions checking the validators of the partially obtained request."></p> <p>The principle is simple, but there is one potential problem: if the downloaded resource has been modified in-between the two downloads, the obtained ranges will correspond to two different versions of the resource and the final document will be corrupted.</p> <p>To prevent this, conditional requests are used. For ranges, they are two ways of doing this. The more flexible one makes use of <a title="The If-Modified-Since request HTTP header makes the request conditional: the server will send back the requested resource, with a 200 status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a 304 without any body; the Last-Modified header will contain the date of last modification. Unlike If-Unmodified-Since, If-Modified-Since can only be used with a GET or HEAD." href="headers/if-modified-since"><code>If-Modified-Since</code></a> and <a title="The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case." href="headers/if-match"><code>If-Match</code></a> and the server returns an error if the precondition fails; the client then restarts the download from the beginning.</p> <p><img src="https://mdn.mozillademos.org/files/13739/HTTPResume3.png" alt="When the partially downloaded resource has been modified, the preconditions will fail and the resource will have to be downloaded again completely."></p> <p>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs the performance and HTTP has an extra specific header to avoid this: <a title="The If-Range request HTTP header makes the range request conditional: if the condition is fulfilled, the range request will be and the server send back a 206 Partial Content answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a 200 OK status." href="headers/if-range"><code>If-Range</code></a>.</p> <p><img src="https://mdn.mozillademos.org/files/13741/HTTPResume4.png" style="height: 263px; width: 770px;" alt="The If-Range headers allows the server to directly send back the complete resource if it has been modified, no need to send a 412 error and wait for the client to re-initiate the download."></p> <p>This solution is more efficient, but slightly less flexible (only one etag can be used in the condition), though this added flexibility is rarely needed.</p> <h3 id="Avoiding_the_lost_update_problem_with_optimistic_locking">Avoiding the lost update problem with optimistic locking</h3> <p>A common operation in Web applications is to <em>update</em> a remote document. This is very common in any file system or source control applications, but any application that allows to store remote resources needs such a mechanism. Similarly, common Web sites like wikis and other CMS have such a need.</p> <p>With the <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a> method you are able to implement this. The client first reads the original files, modifies them and finally pushes them to the server.</p> <p><img src="https://mdn.mozillademos.org/files/13743/HTTPLock1.png" alt="Updating a file with a PUT is very simple when concurrency is not involved."></p> <p>Unfortunately, things get a little bit awry as soon as we take into account concurrency. While a client is modifying locally its new copy of the resource, a second client can fetch the same resource and do the same on its side. What happens then is very unfortunate: when they commit back, the modifications of the first client to push are discarded by the next push, as the second client is unaware of the new changes. The decision about who wins is not communicated to the other party, but which client's changes will be kept will vary with the speed they commit, which depends on the performance of the clients, of the server, and even of the human editing the document at the client: the winner will change from one time to another. This is a <a title="The definition of that term (race condition) has not been written yet; please consider contributing it!" href="https://developer.mozilla.org/en-US/docs/Glossary/race_condition" class="glossaryLink">race condition</a> and leads to problematic behaviors difficult to detect and to debug.</p> <p><img src="https://mdn.mozillademos.org/files/13749/HTTPLock2.png" style="height: 504px; width: 904px;" alt="When several clients update the same resource in parallel, we are facing a race condition: the slowest win, and the others don't even know they lost. Problematic!"></p> <p>There is no way in dealing with this problem without annoying one of the two clients. But lost updates and race conditions are to be avoided: we want a predictable results and that the clients are notified when their changes are rejected.</p> <p>Conditional requests allow to implement the <em>optimistic locking algorithm</em> (used by most wikis or source control systems). The idea is to allow all clients to get copies of the resource, to let them modify it locally and to control concurrency by allowing the first client submitting an update to do it successfully, all subsequent updates based on the now obsolete version of the resource are rejected.</p> <p><img src="https://mdn.mozillademos.org/files/13751/HTTPLock3.png" style="height: 471px; width: 904px;" alt="Conditional requests allow to implement optimistic locking: now the quickest wins, and the others get an error."></p> <p>This is implemented using the <a title="The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case." href="headers/if-match"><code>If-Match</code></a> or <a title="The If-Unmodified-Since request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a POST or another non-safe method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a 412 (Precondition Failed) error." href="headers/if-unmodified-since"><code>If-Unmodified-Since</code></a> headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a <a title="The HTTP 412 Precondition Failed client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than GET or HEAD when the condition defined by the If-Unmodified-Since or If-None-Match headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back." href="status/412"><code>412</code></a> <code>Precondition Failed</code> error. It is up to the client to then deal with the error, either by notifying the human behind to start again, this time on the newest version, or by helping the person by showing them a "diff" and letting the human choose the changes to keep.</p> <h3 id="Dealing_with_the_first_upload_of_a_resource">Dealing with the first upload of a resource</h3> <p>The first upload of a resource is an edge case of the previous: like for any update of a resource, it is subject to a race condition if two clients try to perform it at the same time (or almost). To prevent this, conditional requests can be used: by adding <a title="The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if doesn't have a ETag matching the given one. For other methods, the request will be processed only if the eventually existing resource's ETag doesn't match any of the values listed." href="headers/if-none-match"><code>If-None-Match</code></a> with the special value of <code>'*'</code>, representing any etag, the request will succeed only if the resource didn't exist before.</p> <p><img src="https://mdn.mozillademos.org/files/13753/HTTPFirst.png" style="height: 311px; width: 895px;" alt="Like for a regular upload, the first upload of a resource is subject to a race condition: If-None-Match can prevent it."></p> <p><code>If-None-Match</code> will work only with HTTP/1.1-compliant server (and later). If you don't know if the server will be compliant, you need first to issue a <a title="The HTTP HEAD method requests the headers that are returned if the specified resource would be requested with an HTTP GET method. Such a request can be done before deciding to download a large resource to save bandwidth, for example." href="methods/head"><code>HEAD</code></a> request to the resource to check it.</p> <h2 id="Conclusion">Conclusion</h2> <p>Conditional requests are a key feature of HTTP and allow to build efficient and complex applications. For caching, or resuming downloads, the only work requested to webmasters is to configure the server correctly (setting up correct etags in some environment can be tricky), and Web developers have nothing to do as the browser will serve the right conditional requests.</p> <p>For locking mechanisms, it is the opposite, Web developers need to issue request with the proper headers, while webmasters can rely on the application most of the time to make the check for them.</p> <p>In both cases, conditional requests are a fundamental feature of the Web.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests</a>
  </p>
</div>
