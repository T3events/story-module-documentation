<h1>Caching</h1> <p class="summary">The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</p> <h2 id="Different_kinds_of_caches">Different kinds of caches</h2> <p>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading from the originating server. This achieves several goals: it eases the load of the server that doesn’t need to serve all clients itself, and it improves performance by being closer to the client, i.e., it takes less time to transmit the resource back. For a web site, it is a major component in achieving high performance. On the other side, it has to be configured properly as not all resources stay identical forever: it is important to cache a resource only until it changes, not longer.</p> <p>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A <em>shared cache</em> is a cache that stores responses for reuse by more than one user. A <em>private cache</em> is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</p> <p><img src="https://mdn.mozillademos.org/files/13777/HTTPCachtType.png" alt="What a cache provide, advantages/disadvantages of shared/private caches." style="height: 573px; width: 910px;"></p> <h3 id="Private_browser_caches">Private browser caches</h3> <p>A private cache is dedicated to a single user. You might have seen "caching" in your browser's settings already. A browser cache holds all documents downloaded via <a title="en/HTTP" href="index">HTTP</a> by the user. This cache is used to make visited documents available for back/forward navigation, saving, viewing-as-source, etc. without requiring an additional trip to the server. It likewise improves offline browsing of cached content.</p> <h3 id="Shared_proxy_caches">Shared proxy caches</h3> <p>A shared cache is a cache that stores responses to be reused by more than one user. For example, an ISP or your company might have set up a web proxy as part of its local network infrastructure to serve many users so that popular resources are reused a number of times, reducing network traffic and latency.</p> <h2 id="Targets_of_caching_operations">Targets of caching operations</h2> <p>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to <a title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data." href="methods/get"><code>GET</code></a> and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</p> <ul> <li>Successful results of a retrieval request: a <a title="The HTTP 200 OK success status response code indicates that the request has succeeded. A 200 response is cacheable by default." href="status/200"><code>200</code></a> (OK) response to a <a title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data." href="methods/get"><code>GET</code></a> request containing a resource like HTML documents, images or files.</li> <li>Permanent redirects: a <a title="The HTTP 301 Moved Permanently redirect status response code indicates that the resource requested has been definitively moved to the URL given by the Location headers. A browser redirects to this page, and search engines update their links to the resource (In SEO-speak, it is said that the link-juice is sent to the new URL)." href="status/301"><code>301</code></a> (Moved Permanently) response.</li> <li>Error responses: a <a title="The HTTP 404 Not Found client error response code indicates that a server can not find the requested resource. This response code probably is most famous one due to its frequency to occur in the web. These are often called broken or dead links and lead to link rot." href="status/404"><code>404</code></a> (Not Found) result page.</li> <li>Incomplete results: a <a title="The HTTP 206 Partial Content success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the Range header of the request." href="status/206"><code>206</code></a> (Partial Content) response.</li> <li>Responses other than <a title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data." href="methods/get"><code>GET</code></a> if something suitable for use as a cache key is defined.</li> </ul> <p>A cache entry might also consist of multiple stored responses differentiated by a secondary key, if the request is target of content negotiation. For more details see the information about the <a title="The Vary HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a content negotiation algorithm." href="headers/vary"><code>Vary</code></a> header <a href="#Varying_responses">below</a>.</p> <h2 id="Controlling_caching">Controlling caching</h2> <h3 id="The_Cache-control_header">The <code>Cache-control</code> header</h3> <p>The <a title="The Cache-Control general-header field is used to specify directives for caching mechanisms in both, requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response." href="headers/cache-control"><code>Cache-Control</code></a> HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</p> <h4 id="No_cache_storage_at_all">No cache storage at all</h4> <p>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</p> <pre>Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
</pre> <h4 id="No_caching">No caching</h4> <p>A cache will send the request to the origin server for validation before releasing a cached copy.</p> <pre>Cache-Control: no-cache</pre> <h4 id="Private_and_public_caches">Private and public caches</h4> <p>The "public" directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached. On the other hand, "private" indicates that the response is intended for a single user only and must not be stored by a shared cache. A private browser cache may store the response in this case.</p> <pre>Cache-Control: private
Cache-Control: public
</pre> <h4 id="Expiration">Expiration</h4> <p>The most important directive here is "<code>max-age=&lt;seconds&gt;</code>" which is the maximum amount of time a resource will be considered fresh. Contrary to <a title="The Expires header contains the date/time after which the response is considered stale." href="headers/expires"><code>Expires</code></a>, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</p> <p>For more details, see also the <a href="#Freshness">Freshness</a> section below.</p> <pre>Cache-Control: max-age=31536000</pre> <h4 id="Validation">Validation</h4> <p>When using the "<code>must-revalidate</code>" directive, the cache must verify the status of the stale resources before using it and expired ones should not be used. For more details, see the <a href="#Cache_validation">Validation</a> section below.</p> <pre>Cache-Control: must-revalidate</pre> <h3 id="The_Pragma_header">The <code>Pragma</code> header</h3> <p><a title="The Pragma HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present." href="headers/pragma"><code>Pragma</code></a> is a HTTP/1.0 header, it is not specified for HTTP responses and is therefore not a reliable replacement for the general HTTP/1.1 <code>Cache-Control</code> header, although it does behave the same as <code>Cache-Control: no-cache</code>, if the <code>Cache-Control</code> header field is omitted in a request. Use <code>Pragma</code> only for backwards compatibility with HTTP/1.0 clients.</p> <h2 id="Freshness">Freshness</h2> <p>Once a resource is stored in a cache, it could theoretically be served by the cache forever. Caches have finite storage so items are periodically removed from storage. This process is called <em>cache eviction</em>. On the other side, some resources may change on the server so the cache should be updated. As HTTP is a client-server protocol, servers can't contact caches and clients when a resource change; they have to communicate an expiration time for the resource. Before this expiration time, the resource is <em>fresh</em>; after its expiration time, the resource is <em>stale</em>. Eviction algorithms often privileges fresh resources over stale resources. Note that a stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it forwards this requests with a <a title="The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if doesn't have a ETag matching the given one. For other methods, the request will be processed only if the eventually existing resource's ETag doesn't match any of the values listed." href="headers/if-none-match"><code>If-None-Match</code></a> to check if it isn't in fact still fresh. If so, the server returns a <a title="The HTTP 304 Not Modified client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is safe, like a GET or a HEAD request, or when the request is conditional and uses a If-None-Match or a If-Modified-Since header." href="status/304"><code>304</code></a> (Not Modified) header without sending the body of the requested resource, saving some bandwidth.</p> <p>Here is an example of this process with a shared cache proxy:</p> <p><img src="https://mdn.mozillademos.org/files/13771/HTTPStaleness.png" alt="Show how a proxy cache acts when a doc is not cache, in the cache and fresh, in the cache and stale." style="height: 910px; width: 822px;"></p> <p>The freshness lifetime is calculated based on several headers. If a "<code>Cache-control: max-age=N</code>" header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an <a title="The Expires header contains the date/time after which the response is considered stale." href="headers/expires"><code>Expires</code></a> header is present. If an <code>Expires</code> header exists, then its value minus the value of the <a title="The Date general HTTP header contains the date and time at which the message was originated." href="headers/date"><code>Date</code></a> header determines the freshness lifetime. Finally, if neither header is present, look for a <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> header. If this header is present, then the cache's freshness lifetime is equal to the value of the <code>Date</code> header minus the value of the <code>Last-modified</code> header divided by 10.<br> The expiration time is computed as follows:</p> <pre>expirationTime = responseTime + freshnessLifetime - currentAge
</pre> <p>where <code>responseTime</code> is the time at which the response was received according to the browser.</p> <h3 id="Revved_resources">Revved resources</h3> <p>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this make them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</p> <p>Web developers invented a technique that Steve Sounders called <em>revving</em><sup><a href="https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">[1]</a></sup>. Infrequently updated files are named in specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that <em>never</em> changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</p> <p>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</p> <p><img src="https://mdn.mozillademos.org/files/13779/HTTPRevved.png" alt=""></p> <p>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</p> <h2 id="Cache_validation">Cache validation</h2> <p>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the "<code>Cache-control: must-revalidate</code>" header. Another factor is the cache validation preferences in the <code>Advanced-&gt;Cache</code> preferences panel. There is an option to force a validation each time a document is loaded.</p> <p>When a cached document's expiration time has been reached, it is either validated or fetched again. Validation can only occur if the server provided either a <em>strong validator</em> or a <em>weak validator</em>.</p> <h3 id="ETags">ETags</h3> <p>The <a title='The ETag HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other ("mid-air collisions").' href="headers/etag"><code>ETag</code></a> response header is an <em>opaque-to-the-useragent</em> value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the <code>ETag</code> header was part of the response for a resource, the client can issue an <a title="The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if doesn't have a ETag matching the given one. For other methods, the request will be processed only if the eventually existing resource's ETag doesn't match any of the values listed." href="headers/if-none-match"><code>If-None-Match</code></a> in the header of future requests – in order to validate the cached resource.</p> <p>The <a title="The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an ETag header, it is a fallback mechanism. Conditional requests containing If-Modified-Since or If-Unmodified-Since headers make use of this field." href="headers/last-modified"><code>Last-Modified</code></a> response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the <code>Last-Modified</code> header is present in a response, then the client can issue an <a title="The If-Modified-Since request HTTP header makes the request conditional: the server will send back the requested resource, with a 200 status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a 304 without any body; the Last-Modified header will contain the date of last modification. Unlike If-Unmodified-Since, If-Modified-Since can only be used with a GET or HEAD." href="headers/if-modified-since"><code>If-Modified-Since</code></a> request header to validate the cached document.</p> <p>When a validation request is made, the server can either ignore the validation request and response with a normal <a title="The HTTP 200 OK success status response code indicates that the request has succeeded. A 200 response is cacheable by default." href="status/200"><code>200</code></a> <code>OK</code>, or it can return <a title="The HTTP 304 Not Modified client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is safe, like a GET or a HEAD request, or when the request is conditional and uses a If-None-Match or a If-Modified-Since header." href="status/304"><code>304</code></a> <code>Not Modified</code> (with an empty body) to instruct the browser to use its cached copy. The latter response can also include headers that update the expiration time of the cached document.</p> <h2 id="Varying_responses">Varying responses</h2> <p>The <a title="The Vary HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a content negotiation algorithm." href="headers/vary"><code>Vary</code></a> HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</p> <p>When a cache receives a request that can be satisfied by a cached response that has a <code>Vary</code> header field, it must not use that cached response unless all header fields as nominated by the <code>Vary</code> header match in both the original (cached) request and the new request.</p> <p><img src="https://mdn.mozillademos.org/files/13769/HTTPVary.png" alt="The Vary header leads cache to use more HTTP headers as key for the cache." style="height: 817px; width: 752px;"></p> <p>This can be useful for serving content dynamically, for example. When using the <code>Vary: User-Agent</code> header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no <a href="https://en.wikipedia.org/wiki/Cloaking">Cloaking</a> is intended.</p> <pre>Vary: User-Agent</pre> <p>Because the <a title="The User-Agent request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent." href="headers/user-agent"><code>User-Agent</code></a> header value is different ("varies") for mobile and desktop clients, caches will not be used to serve mobile content mistakenly to desktop users or vice versa.</p> <h2 id="See_also">See also</h2> <ul> <li><a href="https://tools.ietf.org/html/rfc7234">RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</a></li> <li><a href="https://www.mnot.net/cache_docs">Caching Tutorial – Mark Nottingham</a></li> <li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">HTTP caching – Ilya Grigorik</a></li> <li>
<a href="https://redbot.org/">RedBot</a>, a tool to check your cache-related HTTP headers.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching</a>
  </p>
</div>
