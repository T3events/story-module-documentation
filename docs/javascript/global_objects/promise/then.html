<h1>promise.then</h1> <p>The <code><strong>then()</strong></code> method returns a <a title="The Promise interface represents a proxy for a value not necessarily known at its creation time. It allows you to associate handlers to an asynchronous action's eventual success or failure. This lets asynchronous methods return values like synchronous methods: instead of the final value, the asynchronous method returns a promise of having a value at some point in the future." href="https://developer.mozilla.org/en-US/docs/Web/API/Promise"><code>Promise</code></a>. It takes up to two arguments: callback functions for the success and failure cases of the <code>Promise</code>.</p> <p>Note: If both arguments are omitted, or are provided non-functions, a new <code>Promise</code> is created with no additional handlers, simply adopting the final state of the <code>Promise</code> that <code>then</code> is called on. If the first argument is omitted or provided a non-function, the new <code>Promise</code> that is created simply adopts the fulfillment state of the <code>Promise</code> that <code>then</code> is called on (if it becomes fulfilled). If the second argument is omitted or provided a non-function, the new <code>Promise</code> that is created simply adopts the rejection state of the <code>Promise</code> that <code>then</code> is called on (if it becomes rejected).</p> <h2 id="Syntax">Syntax</h2> <pre class="syntaxbox"><var>p.then(onFulfilled[, onRejected])</var>;

p.then(function(value) {
   // fulfillment
  }, function(reason) {
  // rejection
});
</pre> <h3 id="Parameters">Parameters</h3> <p><code>then</code> returns a <code>Promise</code> which is determined by the input functions:</p> <ul> <li>If <code>onFulfilled</code> or <code>onRejected</code> throws an error, or returns a <code>Promise</code> which rejects, <code>then</code> returns a rejected <code>Promise</code>.</li> <li>If <code>onFulfilled</code> or <code>onRejected</code> returns a <code>Promise</code> which resolves, or returns any other value, <code>then</code> returns a resolved <code>Promise</code>.</li> </ul> <dl> <dt><code>onFulfilled</code></dt> <dd>A <a title="The Function constructor creates a new Function object. In JavaScript every function is actually a Function object." href="../function"><code>Function</code></a> called when the <code>Promise</code> is fulfilled. This function has one argument, the fulfillment <code>value</code>.</dd> <dt>
<code>onRejected </code><span class="inlineIndicator optional optionalInline">Optional</span>
</dt> <dd>A <a title="The Function constructor creates a new Function object. In JavaScript every function is actually a Function object." href="../function"><code>Function</code></a> called when the <code>Promise</code> is rejected. This function has one argument, the rejection <code>reason</code>.</dd> </dl> <h3 id="Return_value">Return value</h3> <p>A <a title="The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never." href="../promise"><code>Promise</code></a>.</p> <h2 id="Description">Description</h2> <p>As the <code>then</code> and <a title="The catch() method returns a Promise and deals with rejected cases only. It behaves the same as calling Promise.prototype.then(undefined, onRejected)." href="catch"><code>Promise.prototype.catch()</code></a> methods return promises, they can be chained — an operation called <em>composition</em>.</p> <h2 id="Examples">Examples</h2> <h3 id="Using_the_then_method">Using the <code>then</code> method</h3> <pre data-language="js">var p1 = new Promise(function(resolve, reject) {
  resolve('Success!');
  // or
  // reject ("Error!");
});

p1.then(function(value) {
  console.log(value); // Success!
}, function(reason) {
  console.log(reason); // Error!
});
</pre> <h3 id="Chaining">Chaining</h3> <p>The <code>then</code> method returns a <code>Promise</code> which allows for method chaining.</p> <p>You can pass a lambda to <code>then</code> and if it returns a promise, an equivalent <code>Promise</code> will be exposed to the subsequent then in the method chain. The below snippet simulates asynchronous code with the <code>setTimout</code> function. </p> <pre data-language="js">Promise.resolve('foo')
  // 1. Receive "foo" concatenate "bar" to it and resolve that to the next then
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        resolve(string);
      }, 1);
    });
  })
  // 2. receive "foobar", register a callback function to work on that string
  // and print it to the console, but not before return the unworked on
  // string to the next then
  .then(function(string) {
    setTimeout(function() {
      string += 'baz';
      console.log(string);
    }, 1)
    return string;
  })
  // 3. print helpful messages about how the code in this section will be run
  // before string is actually processed by the mocked asynchronous code in the
  // prior then block.  
  .then(function(string) {
    console.log("Last Then:  oops... didn't bother to instantiate and return " +
                "a promise in the prior then so the sequence may be a bit " +
                "surprising");

    // Note that `string` will not have the 'baz' bit of it at this point. This 
    // is because we mocked that to happen asynchronously with a setTimeout function
    console.log(string);
});</pre> <p>When a value is simply returned from within a <code>then</code> lambda, it will effectively return <code>Promise.resolve(&lt;value returned by whichever handler was called&gt;)</code>.</p> <pre data-language="js">var p2 = new Promise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value); // 1
  return value + 1;
}).then(function(value) {
  console.log(value + '- This synchronous usage is virtually pointless'); // 2- This synchronous usage is virtually pointless
});

p2.then(function(value) {
  console.log(value); // 1
});
</pre> <p>A <code>then</code> call will return a rejected promise if the function throws an error or returns a rejected Promise.</p> <pre data-language="js">Promise.resolve()
  .then( () =&gt; {
    // Makes .then() return a rejected promise
    throw 'Oh no!';
  })
  .then( () =&gt; { 
    console.log( 'Not called.' );
  }, reason =&gt; {
    console.error( 'onRejected function called: ', reason );
});</pre> <p>In all other cases, a resolving Promise is returned. In the following example, the first <code>then()</code> will return <code>42</code> wrapped resolving Promise even though the previous Promise in the chain was rejected.</p> <pre data-language="js">Promise.reject()
  .then( () =&gt; 99, () =&gt; 42 ) // onRejected returns 42 which is wrapped in a resolving Promise
  .then( solution =&gt; console.log( 'Resolved with ' + solution ) ); // Resolved with 42</pre> <p>In practice, it is often desirable to catch rejected promises rather than use <code>then</code>'s two case syntax, as demonstrated below.</p> <pre data-language="js">Promise.resolve()
  .then( () =&gt; {
    // Makes .then() return a rejected promise
    throw 'Oh no!';
  })
  .catch( reason =&gt; {
    console.error( 'onRejected function called: ', reason );
  })
  .then( () =&gt; {
    console.log( "I am always called even if the prior then's promise rejects" );
  });</pre> <p><br> You can also use chaining to implement one function with a Promise-based API on top of another such function.</p> <pre data-language="js">function fetch_current_data() {
  // The <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch">fetch</a>() API returns a Promise.  This function
  // exposes a similar API, except the fulfillment
  // value of this function's Promise has had more
  // work done on it.
  return fetch('current-data.json').then((response) =&gt; {
    if (response.headers.get('content-type') != 'application/json') {
      throw new TypeError();
    }
    var j = response.json();
    // maybe do something with j
    return j; // fulfillment value given to user of
              // fetch_current_data().then()
  });
}
</pre> <p>If <code>onFulfilled</code> returns a promise, the return value of <code>then</code> will be resolved/rejected by the promise.</p> <pre data-language="js">function resolveLater(resolve, reject) {
  setTimeout(function () {
    resolve(10);
  }, 1000);
}
function rejectLater(resolve, reject) {
  setTimeout(function () {
    reject(20);
  }, 1000);
}

var p1 = Promise.resolve('foo');
var p2 = p1.then(function() {
  // Return promise here, that will be resolved to 10 after 1 second
  return new Promise(resolveLater);
});
p2.then(function(v) {
  console.log('resolved', v);  // "resolved", 10
}, function(e) {
  // not called
  console.log('rejected', e);
});

var p3 = p1.then(function() {
  // Return promise here, that will be rejected with 20 after 1 second
  return new Promise(rejectLater);
});
p3.then(function(v) {
  // not called
  console.log('resolved', v);
}, function(e) {
  console.log('rejected', e); // "rejected", 20
});
</pre> <h2 id="Specifications">Specifications</h2> <table class="standard-table"> <tbody> <tr> <th scope="col">Specification</th> <th scope="col">Status</th> <th scope="col">Comment</th> </tr> <tr> <td><a hreflang="en" class="external" lang="en" href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.then">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="en-US">The definition of 'Promise.prototype.then' in that specification.</small></a></td> <td><span class="spec-Standard">Standard</span></td> <td>Initial definition in an ECMA standard.</td> </tr> <tr> <td><a hreflang="en" class="external" lang="en" href="https://tc39.github.io/ecma262/#sec-promise.prototype.then">ECMAScript 2017 Draft (ECMA-262)<br><small lang="en-US">The definition of 'Promise.prototype.then' in that specification.</small></a></td> <td><span class="spec-Draft">Draft</span></td> <td> </td> </tr> </tbody> </table> <h2 id="Browser_compatibility">Browser compatibility</h2>  <div id="compat-desktop"><table class="compat-table"> <thead> <tr> <th>Feature</th> <th>Chrome</th> <th>Edge</th> <th>Firefox</th> <th>Internet Explorer</th> <th>Opera</th> <th>Safari</th> <th>Servo</th> </tr> </thead>
<tbody><tr>
<td>Basic Support</td>
<td>32.0</td>
<td><span style="color: #888;">(Yes)</span></td>
<td>29.0</td>
<td><span style="color: #f00;">No support</span></td>
<td>19</td>
<td>7.1</td>
<td><span style="color: #f00;">No support</span></td>
</tr></tbody>
</table></div><div id="compat-mobile"><table class="compat-table"> <thead> <tr> <th>Feature</th> <th>Android</th> <th>Chrome for Android</th> <th>Edge Mobile</th> <th>Firefox for Android</th> <th>IE Mobile</th> <th>Opera Mobile</th> <th>Safari Mobile</th> </tr> </thead>
<tbody><tr>
<td>Basic Support</td>
<td>4.4.4</td>
<td>32.0</td>
<td><span style="color: #888;">(Yes)</span></td>
<td>29</td>
<td><span style="color: #f00;">No support</span></td>
<td><span style="color: #888;">(Yes)</span></td>
<td>8.0</td>
</tr></tbody>
</table></div> <h2 id="See_also">See also</h2> <ul> <li><a title="The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never." href="../promise"><code>Promise</code></a></li> <li><a title="The catch() method returns a Promise and deals with rejected cases only. It behaves the same as calling Promise.prototype.then(undefined, onRejected)." href="catch"><code>Promise.prototype.catch()</code></a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a>
  </p>
</div>
