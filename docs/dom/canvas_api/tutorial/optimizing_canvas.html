<h1>Canvas API: Optimizing canvas</h1><div> <div style="text-align: right;" class="prevnext"> <p><a style="float: left;" href="hit_regions_and_accessibility">« Previous</a><a href="finale">Next »</a></p> </div>
</div> <div class="summary"> <p>The <a title="Use the HTML &lt;canvas&gt; element with the canvas scripting API to draw graphics and animations." href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas"><code>&lt;canvas&gt;</code></a> element is one of the most widely used standards for rendering 2D graphics on the Web. It is used widely in games and complex visualizations. However, as Web sites and apps push canvas to the limits, performance begins to suffer. <span class="seoSummary">This article aims to provide suggestions for optimizing your use of the canvas element, to ensure that your Web site or app performs well.</span></p> </div> <h2 id="Performance_tips">Performance tips</h2> <p>The following is a collection of tips to improve performance</p> <h3 id="Pre-render_similar_primitives_or_repeating_objects_on_an_off-screen_canvas">Pre-render similar primitives or repeating objects on an off-screen canvas</h3> <p>If you find yourself with complex drawing operations on each frame, consider creating an offscreen canvas, draw to it once (or whenever it changes) on the offscreen canvas, then on each frame draw the offscreen canvas.</p> <pre data-language="js">myEntity.offscreenCanvas = document.createElement('canvas');
myEntity.offscreenCanvas.width = myEntity.width;
myEntity.offscreenCanvas.height = myEntity.height;
myEntity.offscreenContext = myEntity.offscreenCanvas.getContext('2d');

myEntity.render(myEntity.offscreenContext);
</pre> <h3 id="Avoid_floating-point_coordinates_and_use_integers_instead">Avoid floating-point coordinates and use integers instead</h3> <p>Sub-pixel rendering occurs when you render objects on a canvas without whole values.</p> <pre data-language="js">ctx.drawImage(myImage, 0.3, 0.5);
</pre> <p>This causes the browser to do extra calculations to create the anti-aliasing effect. To avoid this, make sure to round all co-ordinates used in calls to <a title="The CanvasRenderingContext2D.drawImage() method of the Canvas 2D API provides different ways to draw an image onto the canvas." href="../../canvasrenderingcontext2d/drawimage"><code>drawImage()</code></a> using <a title="The Math.floor() function returns the largest integer less than or equal to a given number." href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"><code>Math.floor()</code></a>, for example.</p> <h3 id="Don’t_scale_images_in_drawImage">Don’t scale images in <code>drawImage</code>
</h3> <p>Cache various sizes of your images on an offscreen canvas when loading as opposed to constantly scaling them in <a title="The CanvasRenderingContext2D.drawImage() method of the Canvas 2D API provides different ways to draw an image onto the canvas." href="../../canvasrenderingcontext2d/drawimage"><code>drawImage()</code></a>.</p> <h3 id="Use_multiple_layered_canvases_for_complex_scenes">Use multiple layered canvases for complex scenes</h3> <p>You may find you have some elements that are frequently changing and moving around whereas other things (like UI) never change. An optimization in this situation is to create layers using multiple canvas elements.</p> <p>For example you could create a UI layer that sits on top of everything and is only drawn during user input. You could create game layer where the frequently updating entities exist and a background layer for entities that rarely update.</p> <pre data-language="html">&lt;div id="stage"&gt;
  &lt;canvas id="ui-layer" width="480" height="320"&gt;&lt;/canvas&gt;
  &lt;canvas id="game-layer" width="480" height="320"&gt;&lt;/canvas&gt;
  &lt;canvas id="background-layer" width="480" height="320"&gt;&lt;/canvas&gt;
&lt;/div&gt;
 
&lt;style&gt;
  #stage {
    width: 480px;
    height: 320px;
    position: relative;
    border: 2px solid black
  }
  canvas { position: absolute; }
  #ui-layer { z-index: 3 }
  #game-layer { z-index: 2 }
  #background-layer { z-index: 1 }
&lt;/style&gt;
</pre> <h3 id="CSS_for_large_background_images">CSS for large background images</h3> <p>If like most games you have a static background image, use a plain <a title="The HTML &lt;div&gt; element is the generic container for flow content and does not inherently represent anything. Use it to group elements for purposes such as styling (using the class or id attributes), marking a section of a document in a different language (using the lang attribute), and so on." href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a> element with a CSS <a title="The background CSS property is a shorthand for setting the individual background values in a single place in the style sheet. background can be used to set the values for one or more of: background-clip, background-color, background-image, background-origin, background-position, background-repeat, background-size, and background-attachment." href="https://developer.mozilla.org/en-US/docs/Web/CSS/background"><code>background</code></a> property and position it under the canvas. This will avoid drawing a large image to the canvas on every tick.</p> <h3 id="Scaling_canvas_using_CSS_transforms">Scaling canvas using CSS transforms</h3> <p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_transforms">CSS transforms</a> are faster by using the GPU. Best case is to not scale the canvas or have a smaller canvas and scale up rather than a bigger canvas and scale down. For Firefox OS, target 480 x 320 px.</p> <pre data-language="js">var scaleX = window.innerWidth / canvas.width;
var scaleY = window.innerHeight / canvas.height;

var scaleToFit = Math.min(scaleX, scaleY);
var scaleToCover = Math.max(scaleX, scaleY);

stage.style.transformOrigin = '0 0'; //scale from top left
stage.style.transform = 'scale(' + scaleToFit + ')';
</pre> <h3 id="Use_the_moz-opaque_attribute_(Gecko_only)">Use the <code>moz-opaque</code> attribute (Gecko only)</h3> <p>If your game uses canvas and doesn’t need to be transparent, set the <code>moz-opaque</code> attribute on the canvas tag. This information can be used internally to optimize rendering.</p> <pre data-language="html">&lt;canvas id="myCanvas" moz-opaque&gt;&lt;/canvas&gt;</pre> <h3 id="More_tips">More tips</h3> <ul> <li>Batch canvas calls together (for example, draw a poly-line instead of multiple separate lines).</li> <li>Avoid unnecessary canvas state changes.</li> <li>Render screen differences only, not the whole new state.</li> <li>Avoid the <a title="The CanvasRenderingContext2D.shadowBlur property of the Canvas 2D API specifies the level of the blurring effect; this value doesn't correspond to a number of pixels and is not affected by the current transformation matrix. The default value is 0." href="../../canvasrenderingcontext2d/shadowblur"><code>shadowBlur</code></a> property whenever possible.</li> <li>Avoid <a href="drawing_text">text rendering</a> whenever possible.</li> <li>Try different ways to clear the canvas (<a title="The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API sets all pixels in the rectangle defined by starting point (x, y) and size (width, height) to transparent black, erasing any previously drawn content." href="../../canvasrenderingcontext2d/clearrect"><code>clearRect()</code></a> vs. <a title="The CanvasRenderingContext2D.fillRect() method of the Canvas 2D API draws a filled rectangle at (x, y) position whose size is determined by width and height and whose style is determined by the fillStyle attribute." href="../../canvasrenderingcontext2d/fillrect"><code>fillRect()</code></a> vs. resizing the canvas)</li> <li>With animations, use <a title="You should call this method whenever you're ready to update your animation onscreen. This will request that your animation function be called before the browser performs the next repaint. The number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers as per W3C recommendation. The callback rate may be reduced to a lower rate when running in background tabs or in hidden &lt;iframe&gt;s in order to improve performance and battery life." href="../../window/requestanimationframe"><code>window.requestAnimationFrame()</code></a> instead of <a title="Calls a function or executes a code snippet repeatedly, with a fixed time delay between each call to that function. Returns an intervalID." href="../../windoworworkerglobalscope/setinterval"><code>window.setInterval()</code></a> .</li> <li>Be careful with heavy physics libraries</li> </ul> <h2 id="See_also">See also</h2> <ul> <li><a href="http://www.html5rocks.com/en/tutorials/canvas/performance/#toc-ref">Improving HTML5 Canvas Performance – HTML5 Rocks</a></li> <li><a href="https://hacks.mozilla.org/2013/05/optimizing-your-javascript-game-for-firefox-os/">Optimizing your JavaScript game for Firefox OS – Mozilla Hacks</a></li> </ul> <div style="text-align: right;" class="prevnext"> <p><a style="float: left;" href="hit_regions_and_accessibility">« Previous</a><a href="finale">Next »</a></p> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a>
  </p>
</div>
