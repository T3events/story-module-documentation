<h1>Fetch API: Using Fetch</h1><div class="notice experimental"> <p> <strong>This is an experimental technology</strong><br>Because this technology's specification has not stabilized, check the <a href="#Browser_compatibility">compatibility table</a> for usage in various browsers. Also note that the syntax and behavior of an experimental technology is subject to change in future versions of browsers as the specification changes.</p> </div> <div class="summary"> <p>The <a href="../fetch_api">Fetch API</a> provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch()</code></a> method that provides an easy, logical way to fetch resources asynchronously across the network.</p> </div> <p>This kind of functionality was previously achieved using <a title="XMLHttpRequest is an API that provides client functionality for transferring data between a client and a server. It provides an easy way to retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just a part of the page without disrupting what the user is doing." href="../xmlhttprequest"><code>XMLHttpRequest</code></a>. Fetch provides a better alternative that can be easily used by other technologies such as <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"><code>Service Workers</code></a>. Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.</p> <h2 id="The_state_of_browser_support">The state of browser support</h2> <p>Fetch is supported in Firefox 39 and above, and Chrome 42 and above.</p> <p>If you want to use it in unsupported browsers, there is also a <a href="https://github.com/github/fetch">Fetch Polyfill</a> available that recreates the functionality for non-supporting browsers. Bear in mind that this is at an experimental stage and not yet feature complete.</p> <div class="note"> <p><strong>Note</strong>: There have been some concerns raised that the <a href="https://fetch.spec.whatwg.org/">Fetch spec</a> is at odds with the <a href="https://streams.spec.whatwg.org/">Streams spec</a>; however, future plans show an intention to integrate Streams with Fetch: read <a href="https://github.com/yutakahirano/fetch-with-streams/">Fetch API integrated with Streams</a> for more information.</p> </div> <h2 id="Feature_detection">Feature detection</h2> <p>Fetch API support can be detected by checking for the existence of <a title="The Headers interface of the Fetch API allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence." href="../headers"><code>Headers</code></a>, <a title="The Request interface of the Fetch API represents a resource request." href="../request"><code>Request</code></a>, <a title="The Response interface of the Fetch API represents the response to a request." href="../response"><code>Response</code></a> or <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch()</code></a> on the <a title="The window object represents a window containing a DOM document; the document property points to the DOM document loaded in that window." href="../window"><code>Window</code></a> or <a title="The Worker interface of the Web Workers API represents a background task that can be easily created and can send messages back to its creator. Creating a worker is as simple as calling the Worker() constructor and specifying a script to be run in the worker thread." href="../worker"><code>Worker</code></a> scope. For example, you might do this in your script:</p> <pre data-language="js">if(self.fetch) {
    // run my fetch request here
} else {
    // do something with XMLHttpRequest?
}</pre> <h2 id="Making_fetch_requests">Making fetch requests</h2> <p>A basic fetch request is really simple to set up. Have a look at the following code:</p> <pre data-language="js">var myImage = document.querySelector('img');

fetch('flowers.jpg')
.then(function(response) {
  return response.blob();
})
.then(function(myBlob) {
  var objectURL = URL.createObjectURL(myBlob);
  myImage.src = objectURL;
});

</pre> <p>Here we are fetching an image across the network and inserting it into an <a title="The HTML &lt;img&gt; element represents an image in the document." href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img"><code>&lt;img&gt;</code></a> element. The simplest use of <code>fetch()</code> takes one argument — the path to the resource you want to fetch — and returns a promise containing the response (a <a title="The Response interface of the Fetch API represents the response to a request." href="../response"><code>Response</code></a> object).</p> <p>This is just an HTTP response of course, not the actual image. To extract the image body content from the response, we use the <a title="The blob() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with a Blob." href="../body/blob"><code>blob()</code></a> method (defined on the <a title="The Body mixin of the Fetch API represents the body of the response/request, allowing you to declare what its content type is and how it should be handled." href="../body"><code>Body</code></a> mixin, which is implemented by both the <a title="The Request interface of the Fetch API represents a resource request." href="../request"><code>Request</code></a> and <a title="The Response interface of the Fetch API represents the response to a request." href="../response"><code>Response</code></a> objects.)</p> <div class="note"> <p><strong>Note</strong>: The Body mixin also has similar methods to extract other types of body content; see the <a href="#Body">Body</a> section for more.</p> </div> <p>An <code>objectURL</code> is then created from the extracted <a title="A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system." href="../blob"><code>Blob</code></a>, which is then inserted into the <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/Img"><code>img</code></a>.</p> <p>Fetch requests are controlled by the <code>connect-src</code> directive of <a href="https://developer.mozilla.org/en-US/docs/Security/CSP/CSP_policy_directives">Content Security Policy</a> rather than the directive of the resources it's retrieving.</p> <h3 id="Supplying_request_options">Supplying request options</h3> <p>The <code>fetch()</code> method can optionally accept a second parameter, an <code>init</code> object that allows you to control a number of different settings:</p> <pre data-language="js">var myHeaders = new Headers();

var myInit = { method: 'GET',
               headers: myHeaders,
               mode: 'cors',
               cache: 'default' };

fetch('flowers.jpg', myInit)
.then(function(response) {
  return response.blob();
})
.then(function(myBlob) {
  var objectURL = URL.createObjectURL(myBlob);
  myImage.src = objectURL;
});

</pre> <p>See <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch()</code></a> for the full options available, and more descriptions.</p> <h3 id="Sending_a_request_with_credentials_included">Sending a request with credentials included</h3> <p>To cause browsers to send a request with credentials included, add <code>credentials: 'include'</code> to the <code>init</code> object you pass to the <code>fetch()</code> method.</p> <pre data-language="js">fetch('https://example.com', {
  credentials: 'include'  
})</pre> <p>To instead ensure browsers don’t include credentials in the request, use <code>credentials: 'omit'</code>.</p> <pre data-language="js">fetch('https://example.com', {
  credentials: 'omit'  
})</pre> <h3 id="Checking_that_the_fetch_was_successful">Checking that the fetch was successful</h3> <p>A <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch()</code></a> promise will reject with a <a title="The TypeError object represents an error when a value is not of the expected type." href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> when a network error is encountered, although this usually means permission issues or similar — a 404 does not constitute a network error, for example. An accurate check for a successful <code>fetch()</code> would include checking that the promise resolved, then checking that the <a title="The ok read-only property of the Response interface contains a boolean stating whether the response was successful (status in the range 200-299) or not." href="../response/ok"><code>Response.ok</code></a> property has a value of true. The code would look something like this:</p> <pre data-language="js">fetch('flowers.jpg')
.then(function(response) {
  if(response.ok) {
    return response.blob();
  }
  throw new Error('Network response was not ok.');
})
.then(function(myBlob) { 
  var objectURL = URL.createObjectURL(myBlob); 
  myImage.src = objectURL; 
})
.catch(function(error) {
  console.log('There has been a problem with your fetch operation: ' + error.message);
});</pre> <h3 id="Supplying_your_own_request_object">Supplying your own request object</h3> <p>Instead of passing a path to the resource you want to request into the <code>fetch()</code> call, you can create a request object using the <a title="The Request() constructor creates a new Request object." href="../request/request"><code>Request()</code></a> constructor, and pass that in as a <code>fetch()</code> method argument:</p> <pre data-language="js">var myHeaders = new Headers();

var myInit = { method: 'GET',
               headers: myHeaders,
               mode: 'cors',
               cache: 'default' };

var myRequest = new Request('flowers.jpg', myInit);

fetch(myRequest)
.then(function(response) {
  return response.blob();
})
.then(function(myBlob) {
  var objectURL = URL.createObjectURL(myBlob);
  myImage.src = objectURL;
});</pre> <p><code>Request()</code> accepts exactly the same parameters as the <code>fetch()</code> method. You can even pass in an existing request object to create a copy of it:</p> <pre data-language="js">var anotherRequest = new Request(myRequest, myInit);</pre> <p>This is pretty useful, as request and response bodies are one use only. Making a copy like this allows you to make use of the request/response again, while varying the <code>init</code> options if desired.</p> <div class="note"> <p><strong>Note</strong>: There is also a <a title="The clone() method of the Request interface creates a copy of the current Request object." href="../request/clone"><code>clone()</code></a> method that creates a copy. This has slightly different semantics to the other copying method — the former will fail if the old request's body has already been read (same for copying a response), whereas <code>clone()</code> won't.</p> </div> <h2 id="Headers">Headers</h2> <p>The <a title="The Headers interface of the Fetch API allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence." href="../headers"><code>Headers</code></a> interface allows you to create your own headers object via the <a title="The Headers() constructor creates a new Headers object." href="../headers/headers"><code>Headers()</code></a> constructor. A headers object is a simple multi-map of names to values:</p> <pre data-language="js">var content = "Hello World";
var myHeaders = new Headers();
myHeaders.append("Content-Type", "text/plain");
myHeaders.append("Content-Length", content.length.toString());
myHeaders.append("X-Custom-Header", "ProcessThisImmediately");</pre> <p>The same can be achieved by passing an array of arrays or an object literal to the constructor:</p> <pre data-language="js">myHeaders = new Headers({
  "Content-Type": "text/plain",
  "Content-Length": content.length.toString(),
  "X-Custom-Header": "ProcessThisImmediately",
});</pre> <p>The contents can be queried and retrieved:</p> <pre data-language="js">console.log(myHeaders.has("Content-Type")); // true
console.log(myHeaders.has("Set-Cookie")); // false
myHeaders.set("Content-Type", "text/html");
myHeaders.append("X-Custom-Header", "AnotherValue");
 
console.log(myHeaders.get("Content-Length")); // 11
console.log(myHeaders.get("X-Custom-Header")); // ["ProcessThisImmediately", "AnotherValue"]
 
myHeaders.delete("X-Custom-Header");
console.log(myHeaders.get("X-Custom-Header")); // [ ]</pre> <p>Some of these operations are only useful in <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"><code>ServiceWorkers</code></a>, but they provide a much nicer API for manipulating headers.</p> <p>All of the Headers methods throw a <code>TypeError</code> if a header name is used that is not a valid HTTP Header name. The mutation operations will throw a <code>TypeError</code> if there is an immutable guard (see below). Otherwise they fail silently. For example:</p> <pre data-language="js">var myResponse = Response.error();
try {
  myResponse.headers.set("Origin", "http://mybank.com");
} catch(e) {
  console.log("Cannot pretend to be a bank!");
}</pre> <p>A good use case for headers is checking whether the content type is correct before you process it further. For example:</p> <pre data-language="js">fetch(myRequest).then(function(response) {
  var contentType = response.headers.get("content-type");
  if(contentType &amp;&amp; contentType.indexOf("application/json") !== -1) {
    return response.json().then(function(json) {
      // process your JSON further
    });
  } else {
    console.log("Oops, we haven't got JSON!");
  }
});</pre> <h3 id="Guard">Guard</h3> <p>Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers objects have a guard property. This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object.</p> <p>Possible guard values are:</p> <ul> <li>
<code>none</code>: default.</li> <li>
<code>request</code>: guard for a headers object obtained from a request (<a title="The headers read-only property of the Request interface contains the Headers object associated with the request." href="../request/headers"><code>Request.headers</code></a>).</li> <li>
<code>request-no-cors</code>: guard for a headers object obtained from a request created with <a title="The mode read-only property of the Request interface contains the mode of the request (e.g., cors, no-cors, cors-with-forced-preflight, same-origin, or navigate.) This is used to determine if cross-origin requests lead to valid responses, and which properties of the response are readable:" href="../request/mode"><code>Request.mode</code></a> <code>no-cors</code>.</li> <li>
<code>response</code>: guard for a Headers obtained from a response (<a title="The headers read-only property of the Response interface contains the Headers object associated with the response." href="../response/headers"><code>Response.headers</code></a>).</li> <li>
<code>immutable</code>: Mostly used for ServiceWorkers; renders a headers object read-only.</li> </ul> <div class="note"> <p><strong>Note</strong>: You may not append or set a <code>request</code> guarded Headers’ <code>Content-Length</code> header. Similarly, inserting <code>Set-Cookie</code> into a response header is not allowed: ServiceWorkers are not allowed to set cookies via synthesized responses.</p> </div> <h2 id="Response_objects">Response objects</h2> <p>As you have seen above, <a title="The Response interface of the Fetch API represents the response to a request." href="../response"><code>Response</code></a> instances are returned when <code>fetch()</code> promises are resolved.</p> <p>They can also be created programmatically via JavaScript, but this is only really useful in <a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"><code>ServiceWorkers</code></a>, when you are providing a custom response to a received request using a <a title="The respondWith() method of the FetchEvent interface is intended for containing code that generates custom responses to the requests coming from the controlled page. This code will resolve by returning a Response or network error to Fetch." href="../fetchevent/respondwith"><code>respondWith()</code></a> method:</p> <pre data-language="js">var myBody = new Blob();

addEventListener('fetch', function(event) {
  event.respondWith(
    new Response(myBody, {
      headers: { "Content-Type" : "text/plain" }
    })
  );
});</pre> <p>The <a title="The Response() constructor creates a new Response object." href="../response/response"><code>Response()</code></a> constructor takes two optional arguments — a body for the response, and an init object (similar to the one that <a title="The Request() constructor creates a new Request object." href="../request/request"><code>Request()</code></a> accepts.)</p> <p>The most common response properties you'll use are:</p> <ul> <li>
<a title="The status read-only property of the Response interface contains the status code of the response (e.g., 200 for a success)." href="../response/status"><code>Response.status</code></a> — An integer (default value 200) containing the response status code.</li> <li>
<a title="The statusText read-only property of the Response interface contains the status message corresponding to the status code (e.g., OK for 200)." href="../response/statustext"><code>Response.statusText</code></a> — A string (default value "OK"),which corresponds to the HTTP status code message.</li> <li>
<a title="The ok read-only property of the Response interface contains a boolean stating whether the response was successful (status in the range 200-299) or not." href="../response/ok"><code>Response.ok</code></a> — seen in use above, this is a shorthand for checking that status is in the range 200-299 inclusive. This returns a <a title="The Boolean object is an object wrapper for a boolean value." href="https://developer.mozilla.org/en-US/docs/Web/API/Boolean"><code>Boolean</code></a>.</li> </ul> <div class="note"> <p><strong>Note</strong>: The static method <a title="The error() method of the Response interface returns a new Response object associated with a network error." href="../response/error"><code>error()</code></a> simply returns an error response. Similarly, <a title="The redirect() method of the Response interface returns a Response resulting in a redirect to the specified URL." href="../response/redirect"><code>redirect()</code></a> returns a response resulting in a redirect to a specified URL. These are also only relevant to Service Workers.</p> </div> <h2 id="Body">Body</h2> <p>Both requests and responses may contain body data. A body is an instance of any of the following types:</p> <ul> <li><a title="The documentation about this has not yet been written; please consider contributing!" href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer"><code>ArrayBuffer</code></a></li> <li>
<a title="ArrayBufferView is a helper type representing any of the following JavaScript TypedArray types:" href="../arraybufferview"><code>ArrayBufferView</code></a> (Uint8Array and friends)</li> <li>
<a title="A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system." href="../blob"><code>Blob</code></a>/File</li> <li>string</li> <li><a title="The URLSearchParams interface defines utility methods to work with the query string of a URL." href="../urlsearchparams"><code>URLSearchParams</code></a></li> <li><a title='The FormData interface provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".' href="../formdata"><code>FormData</code></a></li> </ul> <p>The <a title="The Body mixin of the Fetch API represents the body of the response/request, allowing you to declare what its content type is and how it should be handled." href="../body"><code>Body</code></a> mixin defines the following methods to extract a body (implemented by both <a title="The Request interface of the Fetch API represents a resource request." href="../request"><code>Request</code></a> and <a title="The Response interface of the Fetch API represents the response to a request." href="../response"><code>Response</code></a>). These all return a promise that is eventually resolved with the actual content.</p> <ul> <li><a title="The arrayBuffer() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with an ArrayBuffer." href="../body/arraybuffer"><code>arrayBuffer()</code></a></li> <li><a title="The blob() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with a Blob." href="../body/blob"><code>blob()</code></a></li> <li><a title="The json() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with an object literal containing the JSON data." href="../body/json"><code>json()</code></a></li> <li><a title="The text() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with a USVString object (text)." href="../body/text"><code>text()</code></a></li> <li><a title="The formData() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with a FormData object." href="../body/formdata"><code>formData()</code></a></li> </ul> <p>This makes usage of non-textual data much easier than it was with XHR.</p> <p>Request bodies can be set by passing body parameters:</p> <pre data-language="js">var form = new FormData(document.getElementById('login-form'));
fetch("/login", {
  method: "POST",
  body: form
});</pre> <p>Both request and response (and by extension the <code>fetch()</code> function), will try to intelligently determine the content type. A request will also automatically set a <code>Content-Type</code> header if none is set in the dictionary.</p> <h2 id="Specifications">Specifications</h2> <table class="standard-table"> <tbody> <tr> <th scope="col">Specification</th> <th scope="col">Status</th> <th scope="col">Comment</th> </tr> <tr> <td><a lang="en" hreflang="en" class="external" href="https://fetch.spec.whatwg.org/" title="The 'Fetch' specification">Fetch</a></td> <td><span class="spec-Living">Living Standard</span></td> <td>Initial definition</td> </tr> </tbody> </table> <h2 id="Browser_compatibility">Browser compatibility</h2>  <div id="compat-desktop"> <table class="compat-table"> <tbody> <tr> <th>Feature</th> <th>Chrome</th> <th>Edge</th> <th>Firefox (Gecko)</th> <th>Internet Explorer</th> <th>Opera</th> <th>Safari (WebKit)</th> </tr> <tr> <td>Basic support</td> <td>42<br> 41<sup>[1]</sup>
</td> <td>14</td> <td>
<a title="Released on 2015-06-30." href="https://developer.mozilla.org/en-US/Firefox/Releases/39">39</a> (39)<br> <a title="Released on 2014-12-01." href="https://developer.mozilla.org/en-US/Firefox/Releases/34">34</a> (34)<sup>[1]</sup><br> <a title="Released on 2017-03-07." href="https://developer.mozilla.org/en-US/Firefox/Releases/52">52</a> (52)<sup>[2]</sup>
</td> <td><span style="color: #f00;">No support</span></td> <td>29<br> 28<sup>[1]</sup>
</td> <td><span style="color: #f00;">No support</span></td> </tr> </tbody> </table> </div> <div id="compat-mobile"> <table class="compat-table"> <tbody> <tr> <th>Feature</th> <th>Android</th> <th>Firefox Mobile (Gecko)</th> <th>IE Phone</th> <th>Opera Mobile</th> <th>Safari Mobile</th> <th>Chrome for Android</th> </tr> <tr> <td>Basic support</td> <td><span title="Compatibility unknown; please update this." style="color: rgb(255, 153, 0);">?</span></td> <td><span title="Please update this with the earliest version of support." style="color: #888;">(Yes)</span></td> <td><span style="color: #f00;">No support</span></td> <td><span title="Compatibility unknown; please update this." style="color: rgb(255, 153, 0);">?</span></td> <td><span style="color: #f00;">No support</span></td> <td><span title="Compatibility unknown; please update this." style="color: rgb(255, 153, 0);">?</span></td> </tr> </tbody> </table> </div> <p>[1] This API is implemented behind a preference.</p> <p>[2] Prior to Firefox 52, <code>get()</code> only returned the first value in the specified header, with <code>getAll()</code> returning all values. From 52 onwards, <code>get()</code> now returns all values and <code>getAll()</code> has been deleted.</p> <h2 id="See_also">See also</h2> <ul> <li><a href="../service_worker_api">ServiceWorker API</a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">HTTP access control (CORS)</a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a></li> <li><a href="https://github.com/github/fetch">Fetch polyfill</a></li> <li><a href="https://github.com/mdn/fetch-examples/">Fetch examples on Github</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch</a>
  </p>
</div>
