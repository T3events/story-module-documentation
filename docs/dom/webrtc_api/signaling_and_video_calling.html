<h1>WebRTC API: Signaling and video calling</h1><div class="notice experimental"> <p> <strong>This is an experimental technology</strong><br>Because this technology's specification has not stabilized, check the <a href="#Browser_compatibility">compatibility table</a> for usage in various browsers. Also note that the syntax and behavior of an experimental technology is subject to change in future versions of browsers as the specification changes.</p> </div> <p>Although <a href="../webrtc_api">WebRTC</a> is billed as a fully peer-to-peer technology for the real-time exchange of audio, video, and data, there is one caveat. <a href="session_lifetime#Establishing_a_connection">As discussed elsewhere</a>, in order for two devices on different networks to locate one another, some form of discovery and media format negotiation must take place. This process, called <strong>signaling</strong>, involves both devices connecting to a third, mutually agreed-upon server through which the two devices can locate one another and exchange the needed negotiation messages.</p> <p>In this article, we will enhance the <a href="https://mdn-samples.mozilla.org/s/websocket-chat">WebSocket chat</a> first created as part of our WebSocket documentation (article link forthcoming; it isn't actually online yet) to support opening a two-way video call between users. You can <a href="https://mdn-samples.mozilla.org/s/webrtc-from-chat">try out the sample</a>, and you can <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat">look at the full project</a> on GitHub.</p> <div class="note"> <p>The code on Github and on our test server is currently newer (and better) than the code shown below. This article is in the process of being updated right now; that update should be done soon (you'll know it's done because this note will vanish).</p> </div> <div class="note"> <p>This example uses promises. If you're not already familiar with them, you should <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">read up on them</a>.</p> </div> <h2 id="The_signaling_server">The signaling server</h2> <p>Establishing a WebRTC connection between two devices over the Internet requires the use of a <em>signaling server</em> to figure out how to connect them. How do we create this server and how does the signaling process actually work?</p> <p>The first thing we need is the signaling server itself. WebRTC doesn't specify any particular transport mechanism for the signaling information. You can use anything you like, from <a href="../websocket_api">WebSocket</a> to <a href="../xmlhttprequest" title="XMLHttpRequest is an API that provides client functionality for transferring data between a client and a server. It provides an easy way to retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just a part of the page without disrupting what the user is doing."><code>XMLHttpRequest</code></a> to carrier pigeon for sending the signaling information between the two peers.</p> <p>What's important to note is that the server doesn't need to know what the content of the signaling data is. It's <a href="https://developer.mozilla.org/en-US/docs/Glossary/SDP" class="glossaryLink" title="SDP: SDP (Session Description Protocol) is the standard describing a peer-to-peer connection. SDP contains the codec, source address, and timing information of audio and video.">SDP</a>, but even that doesn't really matter: the content of the message going through the signaling server is a black box for it. All that matters is that when the <a href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" class="glossaryLink" title="ICE: ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">ICE</a> subsystem tells you to send signaling data to the other peer, you do so, and that the other peer knows how to receive that information and deliver it to its ICE subsystem.</p> <h3 id="Readying_the_chat_server_for_signaling">Readying the chat server for signaling</h3> <p>Our <a href="https://github.com/mdn/samples-server/tree/master/s/websocket-chat">chat server</a> uses the <a href="../websocket_api">WebSocket API</a> to send information as <a href="https://developer.mozilla.org/en-US/docs/Glossary/JSON" class="glossaryLink" title="JSON: The JavaScript Object Notation (JSON) is a data-interchange format.  Although not a strict subset, JSON closely resembles a subset of JavaScript syntax. Though many programming languages support JSON, JSON is especially useful for JavaScript-based apps, including websites and browser extensions.">JSON</a> strings between each client and the server. The server supports several message types, to handle tasks such as registering new users, setting usernames, and sending public chat messages. To let it support signaling and ICE negotiation, we need to update the code to allow directing messages to one specific user instead of broadcasting every message to all logged-in users, and to ensure that unrecognized message types are passed through and delivered, even if the server has no idea what they are. This lets us send signaling messages using the same server instead of implementing a separate server.</p> <p>Let's take a look at the changes we need to make to the chat server to support WebRTC signaling. This is in the file <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chatserver.js">chatserver.js</a>.</p> <p>The first change is the addition of the function <code>sendToOneUser()</code>, which, as the name suggests, sends a stringified JSON message to a particular user, given their name.</p> <pre data-language="js">function sendToOneUser(target, msgString) {
  var isUnique = true;
  var i;

  for (i=0; i&lt;connectionArray.length; i++) {
    if (connectionArray[i].username === target) {
      connectionArray[i].sendUTF(msgString);
      break;
    }
  }
}</pre> <p>This function iterates over the list of connected users until it finds one matching the specified username, then sends the message to that user. In this implementation, the message, <code>msgString</code>, is a stringified JSON object; we could have made it take the original message object, but in this specific situation, it's more efficient this way because the message has been stringified already by the time we reach the point of sending the message along.</p> <p>The original chat demo didn't support sending messages to a single specified user, so we modify the main WebSocket message handler to support this. To do so involves a change near the end of the <code>connection.on()</code> function:</p> <pre data-language="js">if (sendToClients) {
  var msgString = JSON.stringify(msg);
  var i;

  // If the message specifies a target username, only send the
  // message to them. Otherwise, send it to every user.
  if (msg.target &amp;&amp; msg.target !== undefined &amp;&amp; msg.target.length !== 0) {
    sendToOneUser(msg.target, msgString);
  } else {
    for (i=0; i&lt;connectionArray.length; i++) {
      connectionArray[i].sendUTF(msgString);
    }
  }
}</pre> <p>This code now looks at the message to be sent out to see if it has a <code>target</code> property specified. This property can be included to specify the username of the person who should receive the outgoing message. If the <code>target</code> parameter is present, the message is sent only to that user by calling the <code>sendToOneUser()</code> method we looked at above. Otherwise, the message is broadcast to all users by iterating over the connection list and sending the message to each user therein.</p> <p>As the existing code already allowed sending arbitrary message types, no additional changes are required. Our clients can now send messages of unknown types to any specific user; this lets them send signaling messages back and forth as needed.</p> <h3 id="Designing_the_signaling_protocol">Designing the signaling protocol</h3> <p>Now that we have a mechanism for exchanging messages, we need a protocol for what those messages will look like. This can be done in different ways; what's demonstrated here is just one possible way to structure signaling messages.</p> <p>Our server uses stringified JSON objects to communicate with its clients. That means our signaling messages will be in JSON format, with contents that specify what kind of messages it is and any information needed to handle the message properly.</p> <h4 id="Exchanging_session_descriptions">Exchanging session descriptions</h4> <p>When first starting the signaling process, an <em>offer</em> is created by the person initiating the call. This offer includes a session description in SDP format, and it needs to be delivered to the callee, that is the person receiving the call. The callee then responds with an <em>answer</em> message, which also contains an SDP description. Our offer messages will use the type <code>"video-offer"</code>, and the answer messages will be <code>"video-answer"</code>. These messages have the following fields:</p> <dl> <dt><code>type</code></dt> <dd>The message type; either <code>"video-offer"</code> or <code>"video-answer"</code>.</dd> <dt><code>name</code></dt> <dd>The sender's username.</dd> <dt><code>target</code></dt> <dd>The username of the person to receive the description (if the caller is sending the message, this specifies the callee, and vice-versa).</dd> <dt><code>sdp</code></dt> <dd>The SDP string describing the local end of the connection (so that from the point of view of the recipient, the SDP describes the remote end of the connection).</dd> </dl> <p>At this point, the two participants in the call know what codecs and video parameters are going to be used for the call. But they still don't know how to transmit the media data itself. That's where <a href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" class="glossaryLink" title="Interactive Connectivity Establishment (ICE): ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">Interactive Connectivity Establishment (ICE)</a> comes in.</p> <h4 id="Exchanging_ICE_candidates">Exchanging ICE candidates</h4> <p>After exchanging session descriptions, the two peers start exchanging ICE candidates. Each ICE candidate describes a possible method by which the peer that created the candidate is able to communicate. Each peer sends candidates in the order it discovers them, and keeps sending them until it runs out of suggestions to make, even if the media is already streaming. As soon as the two peers each suggest a compatible candidate, media begins to flow, but if they later agree on a better (usually higher-performance) pairing, the stream may change formats to match.</p> <p>In theory, this same technique could be used to downgrade to a lower-bandwidth connection if needed but this is not currently supported.</p> <p>The message we'll send through the signaling server to carry ICE candidates has the type <code>"new-ice-candidate"</code>. These messages include these fields:</p> <dl> <dt><code>type</code></dt> <dd>The message type: <code>"new-ice-candidate"</code>.</dd> <dt><code>target</code></dt> <dd>The username of the person with whom negotation is underway; the server will direct the message to that user only.</dd> <dt><code>candidate</code></dt> <dd>The SDP candidate string, describing the proposed connection method.</dd> </dl> <p>Each ICE message suggests a communication protocol (TCP or UDP), IP address, port number, and connection type (for example, whether the specified IP is the peer itself or a relay server), as well as any other information needed to link the two computers together, even if there's NAT or other complications between the two.</p> <div class="note"> <p>The important thing to note is this: the only thing your code is responsible for during ICE negotiation is accepting outgoing candidates from the ICE layer and sending them across the signaling connection to the other peer when your <a href="../rtcpeerconnection/onicecandidate" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>onicecandidate</code></a> handler is executed, and receiving ICE candidate messages from the signaling server (when the <code>"new-ice-candidate"</code> message is received) and delivering them to your ICE layer by calling <a href="../rtcpeerconnection/addicecandidate" title="When a web site or app using RTCPeerConnection receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's ICE agent by calling RTCPeerConnection.addIceCandidate()."><code>RTCPeerConnection.addIceCandidate()</code></a>. That's it. Avoid the temptation to try to make it more complicated than that until you really know what you're doing. That way lies madness.</p> </div> <p>All your signaling server needs to do is send the messages it's asked to send. You may also need to offer some sort of login/authentication functionality as well, but those details depend greatly on your needs and what authentication you prefer to use.</p> <h2 id="Signaling_transaction_flow">Signaling transaction flow</h2> <p>This is how signaling information is transmitted between the two peers which are to be connected, at a basic level: what messages are sent by whom to whom and why.</p> <p>The signaling process involves the exchange of messages among a number of points: each user's instance of the chat system web application, each user's browser, the signaling server, and the Web server hosting the site.</p> <p>Imagine that Naomi and Priya are engaged in a discussion using the chat software and Naomi decides to open a video call between the two in order to facilitate the conversation. Here's the sequence of events that occurs.</p> <p><a href="https://mdn.mozillademos.org/files/12363/WebRTC%20-%20Signaling%20Diagram.svg"><img src="https://mdn.mozillademos.org/files/12363/WebRTC%20-%20Signaling%20Diagram.svg" alt="Diagram of the signaling process" style="height: 865px; width: 700px;"></a></p> <p>We'll see this in more detail as we work our way through the code over the course of this article.</p> <h2 id="ICE_candidate_exchange_process">ICE candidate exchange process</h2> <p>When each peer's ICE layer begins to send candidates, it enters into an exchange that looks like this:</p> <p><a href="https://mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg"><img src="https://mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg" alt="Diagram of ICE candidate exchange process" style="height: 590px; width: 700px;"></a></p> <p>Each side starts sending candidates as soon as it's able to do so (and, similarly, begins processing received candidates as soon as it's ready to do so). Candidates keep flying back and forth until both sides agree on a candidate, at which time media begins to flow. "ICE exchange" doesn't mean the two sides take turns making suggestions. Instead, each side sends candidates when it feels it's appropriate to make a suggestion, and continues to do so until it's run out of ideas or agreement is reached.</p> <p>That means that if conditions change—for example, the network connection deteriorates—one or both peers might suggest switching to a lower-bandwidth media resolution or even to a different codec. Another round of candidate exchange may then take place and media format and/or codec changes may take place if the two peers come to agreement on a new format.</p> <p>See <a href="http://tools.ietf.org/html/5245">RFC 5245: Interactive Connectivity Establishment</a>, <a href="https://tools.ietf.org/html/rfc5245#section-2.6">section 2.6 ("Concluding ICE")</a> if you want to understand better how the process is completed inside the ICE layer, but you really don't need to know. What matters is that candidates are exchanged and then media starts to flow as soon as the ICE layer is happy. All of that, however, happens behind the scenes. Your entire role in the process is in dutifully sending the candidates back and forth through the signaling server. The rest is done for you.</p> <h2 id="The_client_application">The client application</h2> <p>Let's start translating all of this into code.</p> <p>The core to any signaling process is its message handling. As mentioned before, it's not necessary to use WebSocket for signaling, but it's a pretty common solution, and any other solution you might choose should work more or less similarly in terms of the kinds of activity that occur.</p> <h3 id="Updating_the_HTML">Updating the HTML</h3> <p>Our HTML for the client needs a place for the video to be presented. This requires the addition of a couple of video elements, as well as a button to hang up the call:</p> <pre data-language="html">      &lt;div class="flexChild" id="camera-container"&gt;
        &lt;div class="camera-box"&gt;
          &lt;video id="received_video" autoplay&gt;&lt;/video&gt;
          &lt;video id="local_video" autoplay muted&gt;&lt;/video&gt;
          &lt;button id="hangup-button" onclick="hangUpCall();" disabled&gt;
            Hang Up
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;</pre> <p>We have some page structure defined here using <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div" title="The HTML &lt;div&gt; element is the generic container for flow content and does not inherently represent anything. Use it to group elements for purposes such as styling (using the class or id attributes), marking a section of a document in a different language (using the lang attribute), and so on."><code>&lt;div&gt;</code></a> elements, which will give us control over the layout in the page's CSS. We won't get into the details of the layout here, but you can <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chat.css">take a look at the CSS</a> on Github. The important things to note are the two <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="Use the HTML &lt;video&gt; element to embed video content in a document."><code>&lt;video&gt;</code></a> elements, one for the self-view and the other for the opposition, and a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" title="The HTML &lt;button&gt; element represents a clickable button."><code>&lt;button&gt;</code></a>.</p> <p>The <code>&lt;video&gt;</code> element with the <code>id</code> "<code>received_video</code>" will present the video received from the other end of the call once it begins. The <code>autoplay</code> attribute is specified to ensure that once the video starts arriving, it will play at once (so that we don't have to do this explicitly in our code). The "<code>local_video</code>" <code>&lt;video&gt;</code> element presents a preview of what the user's camera sees; the <code>muted</code> attribute is specified because you don't want to hear your local audio in the preview panel.</p> <p>Finally, the "<code>hangup-button</code>" <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" title="The HTML &lt;button&gt; element represents a clickable button."><code>&lt;button&gt;</code></a>, which is used to disconnect from a call, is defined and configured to start out disabled (since no call is in effect) and to call a function <code>hangUpCall()</code> on click. This function's job is to shut down the call and send a notification to the other peer through the signaling server requesting that it do likewise.</p> <h3 id="The_JavaScript_code">The JavaScript code</h3> <p>We'll break the code up into functional areas to better describe how it works. The main body of the code is in the <code>connect()</code> function: it opens up a <a href="../websocket" title="The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."><code>WebSocket</code></a> server on port 6503 and establishes a handler to receive messages which are objects in JSON format. This code continues to handle the text chat messages just as it always did, for the most part.</p> <h4 id="Sending_messages_to_the_signaling_server">Sending messages to the signaling server</h4> <p>Throughout the code, we call <code>sendToServer()</code> in order to send messages to the signaling server. That function uses the WebSocket connection to do its work:</p> <pre data-language="js">function sendToServer(msg) {
  var msgJSON = JSON.stringify(msg);

  connection.send(msgJSON);
}</pre> <p>The passed-in message object is simply converted into a JSON string by calling <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" title="The JSON.stringify() method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."><code>JSON.stringify()</code></a>, then we call the WebSocket connection's <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send" title="The documentation about this has not yet been written; please consider contributing!"><code>send()</code></a> function to transmit the message to the server.</p> <h4 id="UI_to_start_a_call">UI to start a call</h4> <p>The code that handles the "userlist" message calls <code>handleUserlistMsg()</code>, where we set up the handler for each connected user in the user list that's presented to the left of the chat panel. This function receives a message object whose <code>users</code> property is an array of usernames for everyone online. We will look at this code in sections to make the explanation easier to follow.</p> <pre data-language="js">function handleUserlistMsg(msg) {
  var i;

  var listElem = document.getElementById("userlistbox");

  while (listElem.firstChild) {
    listElem.removeChild(listElem.firstChild);
  }

  // …</pre> <p>We get a reference to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul" title="The HTML &lt;ul&gt; element represents an unordered list of items, typically rendered as a bulleted list."><code>&lt;ul&gt;</code></a> that contains the list of usernames into the variable <code>listElem</code> and empty the list, by removing each child element one by one.</p> <div class="note"> <p>Obviously, it would be more efficient to update the list by adding and removing individual users instead of rebuilding the whole list every time it changes, but this is good enough for the purposes of this example.</p> </div> <p>Then we build the new user list:</p> <pre data-language="js">  // …

  for (i=0; i &lt; msg.users.length; i++) {
    var item = document.createElement("li");
    item.appendChild(document.createTextNode(msg.users[i]));
    item.addEventListener("click", invite, false);

    listElem.appendChild(item);
  }
}
</pre> <p>We create and insert <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li" title="The HTML &lt;li&gt; element is used to represent an item in a list. It must be contained in a parent element: an ordered list (&lt;ol&gt;), an unordered list (&lt;ul&gt;), or a menu (&lt;menu&gt;). In menus and unordered lists, list items are usually displayed using bullet points. In ordered lists, they are usually displayed with an ascending counter on the left, such as a number or letter."><code>&lt;li&gt;</code></a> elements in the DOM, one for each user currently connected to the chat server. We add a listener to each fo them so that <code>invite()</code> is called when the name is clicked; that function initiates the process of calling the clicked-upon user.</p> <h4 id="Starting_a_call">Starting a call</h4> <p>When the user clicks on the name of a user they want to call, the <code>invite()</code> function is invoked as the event handler for that <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/click" title="/en-US/docs/Web/Events/click">click</a></code> event:</p> <pre data-language="js">var mediaConstraints = {
  audio: true, // We want an audio track
  video: true // ...and we want a video track
};

function invite(evt) {
  if (myPeerConnection) {
    alert("You can't start a call because you already have one open!");
  } else {
    var clickedUsername = evt.target.textContent;

    if (clickedUsername === myUsername) {
      alert("I'm afraid I can't let you talk to yourself. That would be weird.");
      return;
    }

    targetUsername = clickedUsername;

    createPeerConnection();

    navigator.mediaDevices.getUserMedia(mediaConstraints)
    .then(function(localStream) {
      document.getElementById("local_video").srcObject = localStream;
      myPeerConnection.addStream(localStream);
    })
    .catch(handleGetUserMediaError);
  }
}</pre> <p>The first thing that happens are a couple of quick sanity checks: is there already a call open? Did the user click on their own name? In either case, we don't want to start a new call, so <a href="../window/alert" title="The Window.alert() method displays an alert dialog with the optional specified content and an OK button."><code>alert()</code></a> is called to explain why the call can't be opened.</p> <p>Then we record the name of the user we're calling into the variable <code>targetUsername</code> and call <code>createPeerConnection()</code>, a function which will create and do basic configuration of the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>.</p> <p>Once the <code>RTCPeerConnection</code> has been created, we request access to the user's camera and microphone by calling <a href="../mediadevices/getusermedia" title="The MediaDevices.getUserMedia() method prompts the user for permission to use one video and/or one audio input device such as a camera or screensharing and/or a microphone. If the user provides permission, then the returned Promise is resolved with the resulting MediaStream object. If the user denies permission, or media is not available, then the promise is rejected with PermissionDeniedError or NotFoundError respectively. Note that it is possible for the returned promise to neither resolve nor reject, as the user is not required to make a choice."><code>MediaDevices.getUserMedia()</code></a>, which is exposed to us through the <a href="../mediadevices/getusermedia" title="The MediaDevices.getUserMedia() method prompts the user for permission to use one video and/or one audio input device such as a camera or screensharing and/or a microphone. If the user provides permission, then the returned Promise is resolved with the resulting MediaStream object. If the user denies permission, or media is not available, then the promise is rejected with PermissionDeniedError or NotFoundError respectively. Note that it is possible for the returned promise to neither resolve nor reject, as the user is not required to make a choice."><code>Navigator.mediaDevices.getUserMedia</code></a> property. When this succeeds, thereby fulfilling the returned promise, our <code>then</code> clause is called. It receives as input a <a href="../mediastream" title="The MediaStream interface represents a stream of media content. A stream consists of several tracks such as video or audio tracks. Each track is specified as an instance of MediaStreamTrack."><code>MediaStream</code></a> object representing the stream from the user's camera and microphone.</p> <p>We set the local video preview's <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaElement/srcObject" title="The documentation about this has not yet been written; please consider contributing!"><code>srcObject</code></a> property to the stream and, since the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="Use the HTML &lt;video&gt; element to embed video content in a document."><code>&lt;video&gt;</code></a> element is configured to automatically play incoming video, the stream starts to play in the local preview box.</p> <p>Then we call <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream" title="The RTCPeerConnection.addStream() method adds a MediaStream as a local source of audio or video. If the negotiation already happened, a new one will be needed for the remote peer to be able to use it."><code>myPeerConnection.addStream()</code></a> to add the stream to the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>. This starts feeding our stream to the WebRTC connection, even though it hasn't been fully set up yet. The stream needs to be added to the connection before ICE negotiation can occur since the ICE layer will use information from the stream when negotiating the connection. That comes later when we receive the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event.</p> <p>If an error occurs while trying to get the local media stream, our catch clause calls <code>handleGetUserMediaError()</code>, which displays an appropriate error to the user if necessary.</p> <h4 id="Handling_getUserMedia()_errors">Handling getUserMedia() errors</h4> <p>If the promise returned by <code>getUserMedia()</code> concludes in failure, our <code>handleGetUserMediaError()</code> function is called.</p> <pre data-language="js">function handleGetUserMediaError(e) {
  switch(e.name) {
    case "NotFoundError":
      alert("Unable to open your call because no camera and/or microphone" +
            "were found.");
      break;
    case "SecurityError":
    case "PermissionDeniedError":
      // Do nothing; this is the same as the user canceling the call.
      break;
    default:
      alert("Error opening your camera and/or microphone: " + e.message);
      break;
  }

  closeVideoCall();
}</pre> <p>An error message is displayed in all cases but one. For this example, we ignore "SecurityError" and "PermissionDeniedError" results, treating refusal to grant permission to use the media hardware just like the user canceled the call.</p> <p>Regardless of why the attempt to get the stream fails, we call our <code>closeVideoCall()</code> function to shut down the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> and to release any resources already allocated by the process of attempting to open the call. That code is designed to deal safely with partially-started calls.</p> <h4 id="Creating_the_peer_connection">Creating the peer connection</h4> <p>The <code>createPeerConnection()</code> function is used by both the caller and the callee to construct their <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> objects, which represent their end of the WebRTC connection. It's called by <code>invite()</code> on the caller side and by <code>handleVideoOfferMsg()</code> on the callee side.</p> <p>It's pretty straightforward:</p> <pre data-language="js">var myHostname = window.location.hostname;

function createPeerConnection() {
  myPeerConnection = new RTCPeerConnection({
      iceServers: [     // Information about ICE servers - Use your own!
        {
          urls: "turn:" + myHostname,  // A TURN server
          username: "webrtc",
          credential: "turnserver"
        }
      ]
  });

// …
</pre> <p>Since we're running a STUN/TURN server on the same host as the Web server, we get its domain name using <a href="../htmlhyperlinkelementutils/hostname" title="The URLUtils.hostname property is a DOMString containing the domain of the URL."><code>location.hostname</code></a>.</p> <p>When we call the <code>RTCPeerConnection</code> constructor, we specify parameters which configure the call; the most important one is <code>iceServers</code>, a list of STUN and/or TURN servers for the <a href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" class="glossaryLink" title="ICE: ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">ICE</a> layer to use when trying to establish a route between the caller and the callee. WebRTC uses STUN and/or TURN to find a route and protocol to use to communicate between the two peers, even if they're behind a firewall or using NAT.</p> <div class="note"> <p>You should always use STUN/TURN servers which you own, or which you have specific authorization to use.</p> </div> <p>The <code>iceServers</code> parameter is an array of objects, each of which contains at least an <code>urls</code> field detailing the URLs that server can be reached at. In our example, we provide a single server for the ICE layer to use to attempt to find and link to the other peer: a TURN server running on the same hostname as the Web server. Note the inclusion of username and password information through the <code>username</code> and <code>credential</code> fields for the TURN server's description.</p> <h5 id="Set_up_event_handlers">Set up event handlers</h5> <p>Once the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> is created, we need to set up handlers for the events that matter to us:</p> <pre data-language="js">// …
  myPeerConnection.onicecandidate = handleICECandidateEvent;
  myPeerConnection.onaddstream = handleAddStreamEvent;
  myPeerConnection.onremovestream = handleRemoveStreamEvent;
  myPeerConnection.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
  myPeerConnection.onicegatheringstatechange = handleICEGatheringStateChangeEvent;
  myPeerConnection.onsignalingstatechange = handleSignalingStateChangeEvent;
  myPeerConnection.onnegotiationneeded = handleNegotiationNeededEvent;
}</pre> <p>The first two of these event handlers are required; you have to handle them to do anything involving streamed media with WebRTC. The <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/removestream" title="/en-US/docs/Web/Events/removestream">removestream</a></code> event is useful for detecting the cessation of streaming, so you'll probably use it, too. The other three are not mandatory but have uses that we'll look at a bit. There are a few other events available, but we're not using them at all in this example. While we'll look at the events we use in more detail later, here's a quick summary of each:</p> <dl> <dt><a href="../rtcpeerconnection/onicecandidate" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>RTCPeerConnection.onicecandidate</code></a></dt> <dd>The local ICE layer calls your <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event handler when it needs you to transmit an ICE candidate to the other peer through your signaling server. See <a href="#Sending_ICE_candidates">Sending ICE candidates</a> for more information and to see the code for this example.</dd> <dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onaddstream" title="The RTCPeerConnection.onaddstream event handler is a property containing the code to execute when the addstream event, of type MediaStreamEvent, is received by this RTCPeerConnection. Such an event is sent when a MediaStream is added to this connection by the remote peer. The event is sent immediately after the call setRemoteDescription() and doesn't wait for the result of the SDP negotiation."><code>RTCPeerConnection.onaddstream</code></a></dt> <dd>This handler for the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/addstream" title="/en-US/docs/Web/Events/addstream">addstream</a></code> event is called by the local WebRTC layer to let you know when a remote stream has been added to your connection. This lets you connect the incoming stream to an element to present it, for example. See <a href="#Receiving_new_streams">Receiving new streams</a> for details.</dd> <dt><a href="../rtcpeerconnection/onremovestream" title="The RTCPeerConnection.onremovestream event handler is a property containing the code to execute when the removestream event, of type MediaStreamEvent, is received by this RTCPeerConnection. Such an event is sent when a MediaStream is removed from this connection."><code>RTCPeerConnection.onremovestream</code></a></dt> <dd>This counterpart to <code>onaddstream</code> is called to handle the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/removestream" title="/en-US/docs/Web/Events/removestream">removestream</a></code> event when the remote stream removes a stream from your connection. See <a href="#Handling_the_removal_of_streams">Handling the removal of streams</a>.</dd> <dt><a href="../rtcpeerconnection/oniceconnectionstatechange" title="The RTCPeerConnection.oniceconnectionstatechange property is an event handler which specifies a function to be called when the iceconnectionstatechange event is fired on an RTCPeerConnection instance. This happens when the state of the connection's ICE agent, as represented by the iceConnectionState property, changes."><code>RTCPeerConnection.oniceconnectionstatechange</code></a></dt> <dd>The <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/iceconnectionstatechange" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code> event is sent by the ICE layer to let you know about changes to the state of the ICE connection. This can help you know when the connection has failed or been lost. We'll look at the code for this example in <a href="#ICE_connection_state">ICE connection state</a> below.</dd> <dt><a href="../rtcpeerconnection/onicegatheringstatechange" title="The RTCPeerConnection.onicegatheringstatechange property is an EventHandler which specifies a function to be called when the icegatheringstatechange event is sent to an RTCPeerConnection instance. This happens when the ICE gathering state—that is, whether or not the ICE agent is actively gathering candidates—changes."><code>RTCPeerConnection.onicegatheringstatechange</code></a></dt> <dd>The ICE layer sends you the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icegatheringstatechange" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code> event when the ICE agent's process of collecting candidates shifts from one state to another (such as starting to gather candidates or completing negotiation). See <a href="#ICE_gathering_state">ICE gathering state</a> below.</dd> <dt><a href="../rtcpeerconnection/onsignalingstatechange" title="The RTCPeerConnection.onsignalingstatechange property is an EventHandler which specifies a function to be called when the signalingstatechange event occurs on an RTCPeerConnection interface. The function receives as input the event object, of type Event; this event is sent when the value of RTCPeerConnection.signalingState changes, as the result of a call to either setLocalDescription() or setRemoteDescription()."><code>RTCPeerConnection.onsignalingstatechange</code></a></dt> <dd>The WebRTC infrastructure sends you the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/signalingstatechange" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code> message when the state of the signaling process (or of the connection to the signaling server) changes. See <a href="#Signaling_state">Signaling state</a> to see our code.</dd> <dt><a href="../rtcpeerconnection/onnegotiationneeded" title="The RTCPeerConnection.onnegotiationneeded property is an EventHandler which specifies a function which is called to handle the negotiationneeded event when it occurs on an RTCPeerConnection instance. This event is fired when a change has occurred which requires session negotiation."><code>RTCPeerConnection.onnegotiationneeded</code></a></dt> <dd>This function is called whenever the WebRTC infrastructure needs you to start the session negotiation process anew. Its job is to create and send an offer to the callee, asking it to connect with us. See <a href="#Starting_negotiation">Starting negotiation</a> to see how we handle this.</dd> </dl> <h4 id="Starting_negotiation">Starting negotiation</h4> <p>Once the caller has created its <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, created a media stream, and added it to the connection as shown in <a href="#Starting_a_call">Starting a call</a>, the browser will fire a <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event when it's ready to attempt a connection with another peer. Here's what our code for handling of this event looks like:</p> <pre data-language="js">function handleNegotiationNeededEvent() {
  myPeerConnection.createOffer().then(function(offer) {
    return myPeerConnection.setLocalDescription(offer);
  })
  .then(function() {
    sendToServer({
      name: myUsername,
      target: targetUsername,
      type: "video-offer",
      sdp: myPeerConnection.localDescription
    });
  })
  .catch(reportError);
}</pre> <p>To start the negotiation process, we need to create and send an SDP offer to the peer to which we want to connect. This offer will include a list of supported configurations for the connection, including information about the media stream we've added to the connection locally (that is, the video we want to send to the other end of the call) and any ICE candidates that may have been gathered by the ICE layer already. We create this offer by calling <a href="../rtcpeerconnection/createoffer" title="The createOffer() method of the RTCPeerConnection interface initiates the creation of an SDP offer which includes information about any MediaStreamTracks already attached to the WebRTC session, codec and options supported by the browser, and any candidates already gathered by the ICE agent, for the purpose of being sent over the signaling channel to a potential peer to request a connection or to update the configuration of an existing connection."><code>myPeerConnection.createOffer()</code></a>. When that succeeds (fulfilling the promise), we pass the created offer into <a href="../rtcpeerconnection/setlocaldescription" title="The RTCPeerConnection.setLocalDescription() method changes the local description associated with the connection. This description specifies the properties of the local end of the connection, including the media format."><code>myPeerConnection.setLocalDescription()</code></a>, which configures the initial connection and media configuration state for the caller's end of the connection, based on the information in the offer.</p> <div class="note"> <p>Technically speaking, the blob returned by <code>createOffer()</code> is an <a href="http://tools.ietf.org/html/3264">RFC 3264</a> offer.</p> </div> <p>We know the description was valid and has been set when the promise returned by <code>setLocalDescription()</code> is fulfilled; that's when we send our offer along to the other peer by creating a new <code>"video-offer"</code> message containing the local description (which is now the same as the offer) and sending it through our signaling server to the callee, thereby transmitting the initial offer to the callee. The offer has the following members:</p> <dl> <dt><code>type</code></dt> <dd>The message type: <code>"video-offer"</code>.</dd> <dt><code>name</code></dt> <dd>The caller's username.</dd> <dt><code>target</code></dt> <dd>The name of the user we wish to call.</dd> <dt><code>sdp</code></dt> <dd>The SDP blob describing the offer.</dd> </dl> <p>If an error occurs either in the initial <code>createOffer()</code> or in any of the fulfillment handlers that follow, an error is reported by calling our <code>reportError()</code> function.</p> <p>Once <code>setLocalDescription()</code>'s fulfillment handler has run, the ICE agent begins firing <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> events that we must handle.</p> <h4 id="Session_negotiation">Session negotiation</h4> <p>Now we're negotiating with the other peer, which will receive our offer, which gets passed to its <code>handleVideoOfferMsg()</code> function. We'll pick the story back up again with the <code>"video-offer"</code> message's arrival at the other callee.</p> <h5 id="Handling_the_invitation">Handling the invitation</h5> <p>When the offer arrives, the callee's <code>handleVideoOfferMsg()</code> function is called; it is passed the <code>"video-offer"</code> message containing the offer. This code needs to do two things. FIrst, it needs to create its own <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> and media stream. Second, it needs to process the received offer and construct and send its answer.</p> <pre data-language="js">function handleVideoOfferMsg(msg) {
  var localStream = null;

  targetUsername = msg.name;

  createPeerConnection();

  var desc = new RTCSessionDescription(msg.sdp);

  myPeerConnection.setRemoteDescription(desc).then(function () {
    return navigator.mediaDevices.getUserMedia(mediaConstraints);
  })
  .then(function(stream) {
    localStream = stream;

    document.getElementById("local_video").srcObject = localStream;
    return myPeerConnection.addStream(localStream);
  })

// …
</pre> <p class="brush: js">This code is very similar to what we did in the <code>invite()</code> function up in <a href="#Starting_a_call">Starting a call</a>. It starts by creating and configuring an <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> using our <code>createPeerConnection()</code> function. Then it takes the SDP offer from the received <code>"video-offer"</code> message and uses it to create a new <a href="../rtcsessiondescription" title="The RTCSessionDescription interface represents the parameters of a session. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session."><code>RTCSessionDescription</code></a> object representing the caller's session description.</p> <p class="brush: js">The session description is then passed into <a href="../rtcpeerconnection/setremotedescription" title="The RTCPeerConnection.setRemoteDescription() method changes the remote description associated with the connection. This description specifies the properties of the remote end of the connection, including the media format."><code>myPeerConnection.setRemoteDescription()</code></a>. This establishes the received offer as the caller's session information. If this is successful, the promise fulfillment handler (in the <code>then()</code> clause) starts the process of getting access to the callee's camera and microphone, setting up the stream, and so forth, just like in <code>invite()</code>.</p> <p class="brush: js">Once the local stream is up and running, it's time to create an SDP answer and send it to the caller:</p> <pre data-language="js">  .then(function() {
    return myPeerConnection.createAnswer();
  })
  .then(function(answer) {
    return myPeerConnection.setLocalDescription(answer);
  })
  .then(function() {
    var msg = {
      name: myUsername,
      target: targetUsername,
      type: "video-answer",
      sdp: myPeerConnection.localDescription
    };

    sendToServer(msg);
  })
  .catch(handleGetUserMediaError);
}</pre> <p>Once <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream" title="The RTCPeerConnection.addStream() method adds a MediaStream as a local source of audio or video. If the negotiation already happened, a new one will be needed for the remote peer to be able to use it."><code>RTCPeerConnection.addStream()</code></a> successfully completes execution and the next fulfillment handler is called, we call <a href="../rtcpeerconnection/createanswer" title="The createAnswer() method on the RTCPeerConnection interface creates an answer to an offer received from a remote peer during the offer/answer negotiation of a WebRTC connection. Once the answer is created, it should be sent to the source of the offer to continue the negotiation process."><code>myPeerConnection.createAnswer()</code></a> to construct an SDP answer string, which is passed to <a href="../rtcpeerconnection/setlocaldescription" title="The RTCPeerConnection.setLocalDescription() method changes the local description associated with the connection. This description specifies the properties of the local end of the connection, including the media format."><code>myPeerConnection.setLocalDescription</code></a> in order to establish that answer's SDP as a description of the callee's local end of the connection.</p> <p>Then the answer is sent to the caller so it knows how to reach the callee; this is done by constructing a <code>"video-answer"</code> message whose <code>sdp</code> property contains the callee's answer.</p> <p>Any errors are caught and passed to <code>handleGetUserMediaError()</code>, described in <a href="#Handling_getUserMedia()_errors">Handling getUserMedia() errors</a>.</p> <div class="note"> <p>As is the case with the caller, once the <code>setLocalDescription()</code> fulfillment handler has run, the browser begins firing <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> events that the callee must handle.</p> </div> <h5 id="Sending_ICE_candidates">Sending ICE candidates</h5> <p>You might think that once the caller receives an answer from the callee, everything's finished, but it's not. Behind the scenes, the ICE agents of each peer need to furiously exchange ICE candidate messages. Each peer needs to send candidates to the other repeatedly until it has told the other peer about every way in which it can be contacted for each of the needed media transports. These candidates must be sent through your signaling server; since ICE doesn't know anything about your signaling server, your code is asked to handle transmission of each candidate by calling your handler for the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event.</p> <p>Your <a href="../rtcpeerconnection/onicecandidate" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>onicecandidate</code></a> handler receives an event whose <code>candidate</code> property is the SDP describing the candidate (or <code>null</code> to mark the end of candidates); this is what you need to transmit to the other peer through your signaling server. Here's our example's implementation:</p> <pre data-language="js">function handleICECandidateEvent(event) {
  if (event.candidate) {
    sendToServer({
      type: "new-ice-candidate",
      target: targetUsername,
      candidate: event.candidate
    });
  }
}</pre> <p>This is pretty simple; it simply builds an object containing the candidate and sends it to the other peer. The <code>sendToServer()</code> function is described in <a href="#Sending_messages_to_the_signaling_server">Sending messages to the signaling server</a>. The properties in the message are:</p> <dl> <dt><code>target</code></dt> <dd>The name of the user the ICE candidate needs to be sent to. This lets the signaling server route the message.</dd> <dt><code>type</code></dt> <dd>The message type: <code>"new-ice-candidate"</code>.</dd> <dt><code>candidate</code></dt> <dd>The candidate object the ICE layer wants us to transmit to the other peer.</dd> </dl> <p>The format of this message (as is the case with everything you do when handling signaling) is entirely up to you, and depends on your needs; you can provide other information as necessary.</p> <div class="note"> <p>It's important to keep in mind that the <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event is <strong>not</strong> sent when ICE candidates arrive from the other end of the call. Instead, they're sent by your own end of the call so that you can take on the job of transmitting the data over whatever channel you choose. This can be confusing when you're new to WebRTC.</p> </div> <h5 id="Receiving_ICE_candidates">Receiving ICE candidates</h5> <p>The signaling server delivers each ICE candidate to the destination peer using whatever means it chooses; in our case as JSON objects with the <code>type</code> <code>"new-ice-candidate"</code>. Our <code>handleNewICECandidateMsg()</code> function is called to handle these messages:</p> <pre data-language="js">function handleNewICECandidateMsg(msg) {
  var candidate = new RTCIceCandidate(msg.candidate);

  myPeerConnection.addIceCandidate(candidate)
    .catch(reportError);
}</pre> <p>We construct an <a href="../rtcicecandidate" title="The RTCIceCandidate interface of the the WebRTC API represents a candidate internet connectivity establishment (ICE) server for establishing an RTCPeerConnection."><code>RTCIceCandidate</code></a> object by passing the received SDP into its constructor, then pass the new object into <a href="../rtcpeerconnection/addicecandidate" title="When a web site or app using RTCPeerConnection receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's ICE agent by calling RTCPeerConnection.addIceCandidate()."><code>myPeerConnection.addIceCandidate()</code></a>. That hands off the newly-received ICE candidate to the local ICE layer, and our role in the process of handling that candidate is complete.</p> <p>Each peer sends to the other peer a candidate for each connection method it knows should work. Eventually, the two sides will come to agreement and open their connection; keep in mind that candidates can still keep coming and going after the conversation has begun, either while trying to find a better connection method or simply because they were already underway when the peers finished establishing their connection.</p> <h5 id="Receiving_new_streams">Receiving new streams</h5> <p>When a new stream is added to the connection by the remote peer (by that peer expressly calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream" title="The RTCPeerConnection.addStream() method adds a MediaStream as a local source of audio or video. If the negotiation already happened, a new one will be needed for the remote peer to be able to use it."><code>RTCPeerConnection.addStream()</code></a> or automatically due to a renegotiation of the stream format), an <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/addstream" title="/en-US/docs/Web/Events/addstream">addstream</a></code> event is triggered. Here's how our sample handles these:</p> <pre data-language="js">function handleAddStreamEvent(event) {
  document.getElementById("received_video").srcObject = event.stream;
  document.getElementById("hangup-button").disabled = false;
}</pre> <p>This function simply assigns the incoming stream to the <code>"received_video"</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="Use the HTML &lt;video&gt; element to embed video content in a document."><code>&lt;video&gt;</code></a> element and enables the button the user can click to hang up the call.</p> <p>Once this code is done running, the video being sent by the other peer is being displayed in the local browser window!</p> <h5 id="Handling_the_removal_of_streams">Handling the removal of streams</h5> <p>Similarly, your code receives a <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/removestream" title="/en-US/docs/Web/Events/removestream">removestream</a></code> event when the remote peer removes a stream from the connection by calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/removeStream" title="The RTCPeerConnection.removeStream() method removes a MediaStream as a local source of audio or video. If the negotiation already happened, a new one will be needed for the remote peer to be able to use it."><code>RTCPeerConnection.removeStream()</code></a>. Our implementation is very simple:</p> <pre data-language="js">function handleRemoveStreamEvent(event) {
  closeVideoCall();
}</pre> <p>All this does is call our <code>closeVideoCall()</code> function to hang up the call, in order to ensure that the call is completely shut down and that all our user interface is ready to start another call. See <a href="#Ending_the_call">Ending the call</a> to understand how that code works.</p> <h4 id="Ending_the_call">Ending the call</h4> <p>There are many reasons why a call might end. Perhaps the call is over and one or both sides have hung up. Maybe a network failure has occurred. Perhaps one user has quit their browser or had a crash unexpectedly.</p> <h5 id="Hanging_up">Hanging up</h5> <p>When the user clicks the "Hang Up" button to end the call, the <code>hangUpCall()</code> function below is called:</p> <pre data-language="js">function hangUpCall() {
  closeVideoCall();
  sendToServer({
    name: myUsername,
    target: targetUsername,
    type: "hang-up"
  });
}</pre> <p><code>hangUpCall()</code> shuts down our end of the call by calling <code>closeVideoCall()</code> to shut down and clean up the connection and the related resources. Then we build a <code>"hang-up"</code> message which we send to the other end of our call. This is how we tell the other peer that the call needs to be closed, so they can neatly shut down their end as well.</p> <h5 id="Ending_the_call_2">Ending the call</h5> <p>The <code>closeVideoCall()</code> function, shown below, is responsible for stopping the streams, cleaning up, and disposing of the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> object:</p> <pre data-language="js">function closeVideoCall() {
  var remoteVideo = document.getElementById("received_video");
  var localVideo = document.getElementById("local_video");

  if (myPeerConnection) {
    if (remoteVideo.srcObject) {
      remoteVideo.srcObject.getTracks().forEach(track =&gt; track.stop());
      remoteVideo.srcObject = null;
    }

    if (localVideo.srcObject) {
      localVideo.srcObject.getTracks().forEach(track =&gt; track.stop());
      localVideo.srcObject = null;
    }

    myPeerConnection.close();
    myPeerConnection = null;
  }

  document.getElementById("hangup-button").disabled = true;

  targetUsername = null;
}</pre> <p>After grabbing references to the two <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="Use the HTML &lt;video&gt; element to embed video content in a document."><code>&lt;video&gt;</code></a> elements, we check to see if a WebRTC connection exists at all; if it does, we proceed to disconnect and close the call, as follows:</p> <ol> <li>For both the remote and local video streams, we iterate over the tracks, calling each track's <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrack/stop" title="The documentation about this has not yet been written; please consider contributing!"><code>MediaTrack.stop()</code></a> method.</li> <li>Set both videos' <a href="../htmlmediaelement/srcobject" title="The srcObject property of the HTMLMediaElement interface sets or returns the object which serves as the source of the media associated with the HTMLMediaElement. This is usually a MediaStream but can, according to the specification, be a MediaSource, Blob, or File."><code>HTMLMediaElement.srcObject</code></a> properties to <code>null</code>, releasing all references to the stream.</li> <li>Close the <a href="../rtcpeerconnection" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> by calling <a href="../rtcpeerconnection/close" title="The RTCPeerConnection.close() method closes the current peer connection."><code>myPeerConnection.close()</code></a>.</li> <li>Set <code>myPeerConnection</code> to <code>null</code>, to ensure that our code knows there's no ongoing call; this is primarily useful when knowing what to do when the user clicks a name in the user list.</li> </ol> <p>Finally, we set the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/disabled" title="The documentation about this has not yet been written; please consider contributing!"><code>disabled</code></a> property to <code>true</code> on the "Hang Up" button, since it shouldn't be clickable while no call is ongoing; then we set <code>targetUsername</code> to <code>null</code> since we're not talking to anyone. This will allow the user to click on another username to call, or to receive an incoming call.</p> <h4 id="Dealing_with_state_changes">Dealing with state changes</h4> <p>There are a number of events you can set up listeners for so that your code is notified of a variety of types of state changes. We use three of them: <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/iceconnectionstatechange" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code>, <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icegatheringstatechange" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code>, and <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/signalingstatechange" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code>.</p> <h5 id="ICE_connection_state">ICE connection state</h5> <p><code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/iceconnectionstatechange" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code> events are sent to us by the ICE layer when the connection state changes (such as when the call is terminated from the other end).</p> <pre data-language="js">function handleICEConnectionStateChangeEvent(event) {
  switch(myPeerConnection.iceConnectionState) {
    case "closed":
    case "failed":
    case "disconnected":
      closeVideoCall();
      break;
  }
}</pre> <p>Here, we call our <code>closeVideoCall()</code> function whenever the ICE connection state changes to <code>"closed"</code>, <code>"failed"</code>, or <code>"disconnected"</code>. That will handle shutting down our end of the connection and going back into a state of being ready to start (or accept) a new call.</p> <h5 id="ICE_signaling_state">ICE signaling state</h5> <p>Similarly, we watch for <code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/signalingstatechange" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code> events, so that if the signaling state changes to "closed", we shut down the call completely.</p> <pre data-language="js">  myPeerConnection.onsignalingstatechange = function(event) {
    switch(myPeerConnection.signalingState) {
      case "closed":
        closeVideoCall();
        break;
    }
  };</pre> <h5 id="ICE_gathering_state">ICE gathering state</h5> <p><code><a href="https://developer.mozilla.org/en-US/docs/Web/Events/icegatheringstatechange" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code> events are used to let you know when the ICE candidate gathering process changes state. Our example doesn't actually use this for anything, but we implement it for logging so you can observe the console log to see how the whole process works.</p> <pre data-language="js">function handleICEGatheringStateChangeEvent(event) {
  // Our sample just logs information to console here,
  // but you can do whatever you need.
}
</pre> <h2 id="Next_steps">Next steps</h2> <p>You can <a href="https://mdn-samples.mozilla.org/s/webrtc-from-chat">play with this sample</a> to see it in action. Open the Web console on both devices and look over the logged output—although you don't see it in the code as shown above, the code on the server (and on <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat">GitHub</a>) has a lot of logging output so you can see how the signaling and connection processes work.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling</a>
  </p>
</div>
