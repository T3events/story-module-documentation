<h1>CSS Animations: Tips</h1><p><span class="seoSummary">CSS Animations make it possible to do incredible things with the elements that make up your documents and apps. However, there are things you might want to do that aren't obvious, or clever ways to do things that you might not come up with right away. This article is a collection of tips and tricks we've found that may make your work easier, including how to run a stopped animation again.</span></p> <h2 name="Run_an_animation_again" id="Run_an_animation_again">Run an animation again</h2> <p>The <a href="../css_animations">CSS Animations</a> specification doesn't offer a way to run an animation again. There's no magic <code>resetAnimation()</code> method on elements, and you can't even just set the element's <a href="../animation-play-state" title="The animation-play-state CSS property determines whether an animation is running or paused. This can be queried to determine whether or not the animation is currently running. In addition, its value can be set to pause and resume playback of an animation."><code>animation-play-state</code></a> to <code>"running"</code> again. Instead, you have to use clever tricks to get a stopped animation to replay.</p> <p>Here's one way to do it that we feel is stable and reliable enough to suggest to you.</p> <h3 id="HTML_content">HTML content</h3> <p>First, let's define the HTML for a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div" title="The HTML &lt;div&gt; element (or HTML Document Division Element) is the generic container for flow content, which does not inherently represent anything. It can be used to group elements for styling purposes (using the class or id attributes), or because they share attribute values, such as lang. It should be used only when no other semantic element (such as &lt;article&gt; or &lt;nav&gt;) is appropriate."><code>&lt;div&gt;</code></a> we wish to animate and a button that will play (or replay) the animation.</p> <pre data-language="html">&lt;div class="box"&gt;
&lt;/div&gt;

&lt;div class="runButton"&gt;Click me to run the animation&lt;/div&gt;</pre> <h3 id="CSS_content">CSS content</h3> <p>Now we'll define the animation itself using CSS. Some CSS that's not important (the style of the "Run" button itself) isn't shown here, for brevity.</p>  <pre data-language="css">@keyframes colorchange {
  0% { background: yellow }
  100% { background: blue }
}

.box {
  width: 100px;
  height: 100px;
  border: 1px solid black;
}

.changing {
  animation: colorchange 2s;
}</pre> <p>There are two classes here. The <code>"box"</code> class is the basic description of the box's appearance, without any animation information included. The animation details are included in the <code>"changing"</code> class, which says that the <a href="../@keyframes" title="The @keyframes CSS at-rule lets authors control the intermediate steps in a CSS animation sequence by establishing keyframes (or waypoints) along the animation sequence that must be reached by certain points during the animation. This gives you more specific control over the intermediate steps of the animation sequence than you'd get when letting the browser handle everything automatically."><code>@keyframes</code></a> named <code>"colorchange"</code> should be used over the course of two seconds to animate the box.</p> <p>Note that because of this, the box doesn't start with any animation effects in place, so it won't be animating.</p> <h3 id="JavaScript_content">JavaScript content</h3> <p>Next we'll look at the JavaScript that does the work. The meat of this technique is in the <code>play()</code> function, which is called when the user clicks on the "Run" button.</p> <pre data-language="js">function play() {
  document.querySelector(".box").className = "box";
  window.requestAnimationFrame(function(time) {
    window.requestAnimationFrame(function(time) {
      document.querySelector(".box").className = "box changing";
    });
  });
}</pre> <p>This looks weird, doesn't it? That's because the only way to play an animation again is to remove the animation effect, let the document recompute styles so that it knows you've done that, then add the animation effect back to the element. To make that happen, we have to be creative.</p> <p>Here's what happens when the <code>play()</code> function gets called:</p> <ol> <li>The box's list of CSS classes is reset to simply <code>"box"</code>. This has the effect of removing any other classes currently applied to the box, including the <code>"changing"</code> class that handles animation. In other words, we're removing the animation effect from the box. However, changes to the class list don't take effect until the style recomputation is complete and a refresh has occurred to reflect the change.</li> <li>To be sure that the styles are recalculated, we use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame" title="You should call this method whenever you're ready to update your animation onscreen. This will request that your animation function be called before the browser performs the next repaint. The number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers as per W3C recommendation. The callback rate may be reduced to a lower rate when running in background tabs or in hidden &lt;iframe&gt;s in order to improve performance and battery life."><code>window.requestAnimationFrame()</code></a>, specifying a callback. Our callback gets executed just before the next repaint of the document. The problem for us is that because it's before the repaint, the style recomputation hasn't actually happened yet! So...</li> <li>Our callback cleverly calls <code>requestAnimationFrame()</code> a second time! This time, the callback is run before the next repaint, which is after the style recomputation has occurred. This callback adds the <code>"changing"</code> class back onto the box, so that the repaint will start the animation once again.</li> </ol> <p>Of course, we also need to add an event handler to our "Run" button so it'll actually do something:</p> <pre data-language="js">document.querySelector(".runButton").addEventListener("click", play, false);</pre> <h3 id="Result">Result</h3> <p><iframe class="live-sample-frame sample-code-frame" height="160" src="https://mdn.mozillademos.org/en-US/docs/Web/CSS/CSS_Animations/Tips%24samples/Run_an_animation_again?revision=1141445" frameborder="0" width="320" id="frame_Run_an_animation_again"></iframe></p> <h2 id="See_also">See also</h2> <ul> <li>CSS Animations</li> <li>Using CSS Animations</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame" title="You should call this method whenever you're ready to update your animation onscreen. This will request that your animation function be called before the browser performs the next repaint. The number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers as per W3C recommendation. The callback rate may be reduced to a lower rate when running in background tabs or in hidden &lt;iframe&gt;s in order to improve performance and battery life."><code>Window.requestAnimationFrame()</code></a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Tips$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Tips" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Tips</a>
  </p>
</div>
